<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>fesystem: TecPlotOutputProcessor Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">fesystem
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">TecPlotOutputProcessor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="TecPlotOutputProcessor" --><!-- doxytag: inherits="OutputProcessor" -->
<p><code>#include &lt;<a class="el" href="_tec_plot_output_processor_8h_source.html">TecPlotOutputProcessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TecPlotOutputProcessor:</div>
<div class="dyncontent">
<div class="center"><img src="class_tec_plot_output_processor__inherit__graph.gif" border="0" usemap="#_tec_plot_output_processor_inherit__map" alt="Inheritance graph"/></div>
<map name="_tec_plot_output_processor_inherit__map" id="_tec_plot_output_processor_inherit__map">
<area shape="rect" id="node2" href="class_output_processor.html" title="OutputProcessor" alt="" coords="26,6,147,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for TecPlotOutputProcessor:</div>
<div class="dyncontent">
<div class="center"><img src="class_tec_plot_output_processor__coll__graph.gif" border="0" usemap="#_tec_plot_output_processor_coll__map" alt="Collaboration graph"/></div>
<map name="_tec_plot_output_processor_coll__map" id="_tec_plot_output_processor_coll__map">
<area shape="rect" id="node2" href="class_output_processor.html" title="OutputProcessor" alt="" coords="209,99,329,127"/><area shape="rect" id="node4" href="class_f_e_system_1_1_f_e_system_controller.html" title="FESystem::FESystemController" alt="" coords="5,6,213,34"/><area shape="rect" id="node6" href="class_output_info.html" title="OutputInfo" alt="" coords="238,6,321,34"/><area shape="rect" id="node8" href="class_mesh_d_s_1_1_f_e_mesh_data.html" title="MeshDS::FEMeshData" alt="" coords="438,99,596,127"/><area shape="rect" id="node10" href="class_mesh_d_s_1_1_f_e_mesh.html" title="MeshDS::FEMesh" alt="" coords="375,6,504,34"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_tec_plot_output_processor-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#a6fe38422372b3ef41be2f00fcb8cf047">TecPlotOutputProcessor</a> (<a class="el" href="class_f_e_system_1_1_f_e_system_controller.html">FESystem::FESystemController</a> &amp;, const <a class="el" href="class_output_info.html">OutputInfo</a> &amp;<a class="el" href="_arpack_eigen_solver_8h.html#ab4bdba131592d57176f37f9670deec34">info</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="#a6fe38422372b3ef41be2f00fcb8cf047"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#aec3e9c718d7e7c63a2d78d9938f3b89f">~TecPlotOutputProcessor</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#aec3e9c718d7e7c63a2d78d9938f3b89f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#a941611cb83b7eb8aca941b9cc4ed65b9">writeData</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">writes data to output file(s)  <a href="#a941611cb83b7eb8aca941b9cc4ed65b9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#a5f3d292486a23ec59ec97aa537273203">prepareElemTypeMap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">prepares the elem type map  <a href="#a5f3d292486a23ec59ec97aa537273203"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#ad8669749e280f9786dc4393f0e8b715b">writeNodalData</a> (std::ostream &amp;output, const unsigned int discipline, const std::vector&lt; std::string &gt; &amp;dof_names)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">writes the thermal data  <a href="#ad8669749e280f9786dc4393f0e8b715b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#a088a7c5dfc89dd4a3bfc89ca2917ceb8">writeStructuralData</a> (std::ostream &amp;output)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mesh_d_s_1_1_f_e_mesh.html">MeshDS::FEMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#a8bd9541679ab178b17b4f679e86d4fcd">mesh</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mesh_d_s_1_1_f_e_mesh_data.html">MeshDS::FEMeshData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#ac112b1d13ee3be674a9b36df4f5c43dc">mesh_data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; Elem * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#af3a612f6c014b3ce04535d6bf43c3e0e">dummy_elem_set</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; ElemType, <br class="typebreak"/>
std::vector&lt; Elem * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tec_plot_output_processor.html#a01d6d96d0373e10575ad2a9bf985c3bd">elem_vec_map</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="_tec_plot_output_processor_8h_source.html#l00047">47</a> of file <a class="el" href="_tec_plot_output_processor_8h_source.html">TecPlotOutputProcessor.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6fe38422372b3ef41be2f00fcb8cf047"></a><!-- doxytag: member="TecPlotOutputProcessor::TecPlotOutputProcessor" ref="a6fe38422372b3ef41be2f00fcb8cf047" args="(FESystem::FESystemController &amp;, const OutputInfo &amp;info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tec_plot_output_processor.html#a6fe38422372b3ef41be2f00fcb8cf047">TecPlotOutputProcessor::TecPlotOutputProcessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_e_system_1_1_f_e_system_controller.html">FESystem::FESystemController</a> &amp;&#160;</td>
          <td class="paramname"><em>fesys_controller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_output_info.html">OutputInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor </p>

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8_c_source.html#l00032">32</a> of file <a class="el" href="_tec_plot_output_processor_8_c_source.html">TecPlotOutputProcessor.C</a>.</p>
<div class="fragment"><pre class="fragment">                                                                      :
<a class="code" href="class_output_processor.html#a2d41b35b6ec770c0b84202d9453ae495">OutputProcessor</a>(fesys_controller, info, TECPLOT_OUTPUT_PROCESSOR::num()),
<a class="code" href="class_tec_plot_output_processor.html#a8bd9541679ab178b17b4f679e86d4fcd">mesh</a>(NULL),
<a class="code" href="class_tec_plot_output_processor.html#ac112b1d13ee3be674a9b36df4f5c43dc">mesh_data</a>(NULL),
<a class="code" href="class_tec_plot_output_processor.html#af3a612f6c014b3ce04535d6bf43c3e0e">dummy_elem_set</a>(NULL)
{
        
}
</pre></div>
</div>
</div>
<a class="anchor" id="aec3e9c718d7e7c63a2d78d9938f3b89f"></a><!-- doxytag: member="TecPlotOutputProcessor::~TecPlotOutputProcessor" ref="aec3e9c718d7e7c63a2d78d9938f3b89f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tec_plot_output_processor.html#aec3e9c718d7e7c63a2d78d9938f3b89f">TecPlotOutputProcessor::~TecPlotOutputProcessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>destructor </p>

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8_c_source.html#l00045">45</a> of file <a class="el" href="_tec_plot_output_processor_8_c_source.html">TecPlotOutputProcessor.C</a>.</p>
<div class="fragment"><pre class="fragment">{
        
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5f3d292486a23ec59ec97aa537273203"></a><!-- doxytag: member="TecPlotOutputProcessor::prepareElemTypeMap" ref="a5f3d292486a23ec59ec97aa537273203" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tec_plot_output_processor.html#a5f3d292486a23ec59ec97aa537273203">TecPlotOutputProcessor::prepareElemTypeMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>prepares the elem type map </p>

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8_c_source.html#l00127">127</a> of file <a class="el" href="_tec_plot_output_processor_8_c_source.html">TecPlotOutputProcessor.C</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//   // first of all, clear the map</span>
<span class="comment">//   this-&gt;elem_vec_map.clear();</span>

<span class="comment">//   // next, iterate over all the elems, and based on the elem type, </span>
<span class="comment">//   // insert them in the vector. Finally, insert the vectors in the </span>
<span class="comment">//   // map</span>
<span class="comment">//   // get the iterator for the elems</span>
<span class="comment">//   MeshBase::const_element_iterator elem_it = this-&gt;mesh-&gt;elements_begin();</span>
<span class="comment">//   MeshBase::const_element_iterator elem_end = this-&gt;mesh-&gt;elements_end();</span>
  
<span class="comment">//   std::set&lt;Elem*&gt;::const_iterator dummy_elem_end =</span>
<span class="comment">//   this-&gt;dummy_elem_set-&gt;end();</span>
  
<span class="comment">//   std::vector&lt;Elem*&gt; *elem_vec=NULL;</span>
        
<span class="comment">//   for (; elem_it != elem_end; elem_it++)</span>
<span class="comment">//     {</span>
<span class="comment">//       if (this-&gt;dummy_elem_set-&gt;find(*elem_it) != dummy_elem_end)</span>
<span class="comment">//      continue;</span>
      
      
<span class="comment">//       // insert this elem type in the map if it does not already exist</span>
<span class="comment">//       if (this-&gt;elem_vec_map.count((**elem_it).type()) == 0)</span>
<span class="comment">//      {</span>
<span class="comment">//        elem_vec = </span>
<span class="comment">//          &amp;(this-&gt;elem_vec_map.insert(std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt;::value_type</span>
<span class="comment">//                                      ((**elem_it).type(), std::vector&lt;Elem*&gt;())).first-&gt;second);</span>
<span class="comment">//      }</span>
<span class="comment">//       else</span>
<span class="comment">//      elem_vec = &amp;(this-&gt;elem_vec_map.find((**elem_it).type())-&gt;second);</span>
      
<span class="comment">//       elem_vec-&gt;push_back(*elem_it);</span>
<span class="comment">//     }</span>
  
        
<span class="comment">//   for (; elem_it != elem_end; elem_it++)</span>
<span class="comment">//     {</span>
<span class="comment">//     Elem* elem = *elem_it;</span>
    
<span class="comment">//     if (this-&gt;dummy_elem_set-&gt;find(elem) != dummy_elem_end)</span>
<span class="comment">//       continue;</span>
    
<span class="comment">//     switch (elem-&gt;type())</span>
<span class="comment">//       {</span>
<span class="comment">//       case EDGE2:</span>
<span class="comment">//         {</span>
<span class="comment">//           edge2_elems.push_back(elem);</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case TRI3:</span>
<span class="comment">//         {</span>
<span class="comment">//           tri3_elems.push_back(elem);</span>
<span class="comment">//         }    </span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case QUAD4:</span>
<span class="comment">//         {</span>
<span class="comment">//           quad4_elems.push_back(elem);</span>
<span class="comment">//         }    </span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case HEX8:</span>
<span class="comment">//       case PRISM6:</span>
<span class="comment">//         {</span>
<span class="comment">//           hex8_elems.push_back(elem);</span>
<span class="comment">//         }    </span>
<span class="comment">//         break;</span>
                                
<span class="comment">//       default:</span>
<span class="comment">//         Assert(false, ExcInternalError());</span>
<span class="comment">//         break;</span>
<span class="comment">//       }</span>
<span class="comment">//     }</span>
  
<span class="comment">//   // next, based on whether the elem vec is non-zero or not, insert them to the</span>
<span class="comment">//   // map</span>
<span class="comment">//   if (edge2_elems.size() &gt; 0)</span>
<span class="comment">//     this-&gt;elem_vec_map.insert(std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt;::value_type</span>
<span class="comment">//                               (EDGE2, edge2_elems));</span>
<span class="comment">//   if (quad4_elems.size() &gt; 0)</span>
<span class="comment">//     this-&gt;elem_vec_map.insert(std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt;::value_type</span>
<span class="comment">//                               (QUAD4, quad4_elems));</span>
<span class="comment">//   if (tri3_elems.size() &gt; 0)</span>
<span class="comment">//     this-&gt;elem_vec_map.insert(std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt;::value_type</span>
<span class="comment">//                               (TRI3, tri3_elems));</span>
<span class="comment">//   if (hex8_elems.size() &gt; 0)</span>
<span class="comment">//     this-&gt;elem_vec_map.insert(std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt;::value_type</span>
<span class="comment">//                               (HEX8, hex8_elems));</span>
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="a941611cb83b7eb8aca941b9cc4ed65b9"></a><!-- doxytag: member="TecPlotOutputProcessor::writeData" ref="a941611cb83b7eb8aca941b9cc4ed65b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tec_plot_output_processor.html#a941611cb83b7eb8aca941b9cc4ed65b9">TecPlotOutputProcessor::writeData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>writes data to output file(s) </p>

<p>Implements <a class="el" href="class_output_processor.html#a7308e7fd93ee0260bdcf6e001b62c343">OutputProcessor</a>.</p>

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8_c_source.html#l00052">52</a> of file <a class="el" href="_tec_plot_output_processor_8_c_source.html">TecPlotOutputProcessor.C</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//   // iterate over the disciplines and write the mesh to </span>
<span class="comment">//   // each discipline&#39;s file</span>
  
<span class="comment">//   std::vector&lt;Discipline::DisciplineInfo*&gt;&amp; disciplines = </span>
<span class="comment">//   this-&gt;fesystem_controller.analysis_case-&gt;getAnalysisDisciplineInfos();</span>
  
<span class="comment">//   unsigned int mesh_ID =0;</span>
  
<span class="comment">//   std::vector&lt;std::string&gt; dof_names;</span>

<span class="comment">//   std::vector&lt;Discipline::DisciplineInfo*&gt;::const_iterator it, end;</span>
<span class="comment">//   it = disciplines.begin();</span>
<span class="comment">//   end = disciplines.end();</span>
  
<span class="comment">//   for (; it !=end ; it++)</span>
<span class="comment">//     {</span>
<span class="comment">//       mesh_ID = (*it)-&gt;getMeshID();</span>
    
<span class="comment">//       // get the mesh and meshdata from mesh list</span>
<span class="comment">//       this-&gt;mesh = </span>
<span class="comment">//      this-&gt;fesystem_controller.mesh_list-&gt;getMeshFromID(mesh_ID);</span>
<span class="comment">//       this-&gt;mesh_data = </span>
<span class="comment">//      this-&gt;fesystem_controller.mesh_list-&gt;getMeshDataFromID(mesh_ID);</span>
<span class="comment">//       this-&gt;dummy_elem_set = </span>
<span class="comment">//      this-&gt;fesystem_controller.mesh_list-&gt;getDummyElemSetFromID(mesh_ID);</span>
      
<span class="comment">//       // get the name of the file to be written to</span>
<span class="comment">//       std::string file_name = </span>
<span class="comment">//      Discipline::AnalysisDisciplineEnum::enumName((*it)-&gt;getDisciplineEnumID());</span>
      
<span class="comment">//       std::string name = this-&gt;output_info.getOutputFileName();</span>
      
<span class="comment">//       file_name += name;</span>
      
<span class="comment">//       // open the file, and call the functions to write the data to this stream</span>
<span class="comment">//       std::fstream output_file;</span>
<span class="comment">//       output_file.open(file_name.c_str(), std::fstream::out);</span>
      
<span class="comment">//       switch((*it)-&gt;getDisciplineEnumID())</span>
<span class="comment">//      {</span>
<span class="comment">//      case THERMAL_DISCIPLINE_ENUM_ID:</span>
<span class="comment">//        {</span>
<span class="comment">//          dof_names.clear();</span>
<span class="comment">//          dof_names.push_back(&quot;Temperature&quot;);</span>
<span class="comment">//        }</span>
<span class="comment">//        break;</span>
          
<span class="comment">//      case STRUCTURAL_DISCIPLINE_ENUM_ID:</span>
<span class="comment">//        {</span>
<span class="comment">//          dof_names.clear();</span>
<span class="comment">//          dof_names.push_back(&quot;u&quot;);</span>
<span class="comment">//          dof_names.push_back(&quot;v&quot;);</span>
<span class="comment">//          dof_names.push_back(&quot;w&quot;);</span>
<span class="comment">//          dof_names.push_back(&quot;theta_x&quot;);</span>
<span class="comment">//          dof_names.push_back(&quot;theta_y&quot;);</span>
<span class="comment">//          dof_names.push_back(&quot;theta_z&quot;);</span>
<span class="comment">//        }</span>
<span class="comment">//        break;</span>
          
<span class="comment">//      default:</span>
<span class="comment">//        Assert(false, ExcInternalError());</span>
<span class="comment">//      }</span>

<span class="comment">//       // now write the nodal solution</span>
<span class="comment">//       this-&gt;writeNodalData(output_file, (*it)-&gt;getDisciplineEnumID(),</span>
<span class="comment">//                         dof_names);</span>
      
<span class="comment">//       output_file.close();</span>
<span class="comment">//     }</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad8669749e280f9786dc4393f0e8b715b"></a><!-- doxytag: member="TecPlotOutputProcessor::writeNodalData" ref="ad8669749e280f9786dc4393f0e8b715b" args="(std::ostream &amp;output, const unsigned int discipline, const std::vector&lt; std::string &gt; &amp;dof_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tec_plot_output_processor.html#ad8669749e280f9786dc4393f0e8b715b">TecPlotOutputProcessor::writeNodalData</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>discipline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>writes the thermal data </p>

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8_c_source.html#l00226">226</a> of file <a class="el" href="_tec_plot_output_processor_8_c_source.html">TecPlotOutputProcessor.C</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//   this-&gt;prepareElemTypeMap();</span>

<span class="comment">//   // get the solution data infos from all the solutions</span>
  
  


<span class="comment">//   // this is the vector in which the data will be obtained and then written from</span>
<span class="comment">//   std::auto_ptr&lt;NumericVector&lt;double&gt; &gt; vector</span>
<span class="comment">//   (NumericVector&lt;double&gt;::build().release()); </span>
  
  
<span class="comment">//   // control parameters</span>
<span class="comment">//   output  &lt;&lt; &quot;TITLE = \&quot; FESystem Output\&quot; &quot; &lt;&lt; &quot;\n&quot;</span>
<span class="comment">//     &lt;&lt; &quot;VARIABLES = \&quot;X\&quot;,  \&quot;Y\&quot;,  \&quot;Z\&quot;&quot;;</span>
  
<span class="comment">//   // iterate over each solution, and prepare a list of nodal and element centered </span>
<span class="comment">//   // variables for the same.</span>
<span class="comment">//   const std::vector&lt;Solution::SolutionBase*&gt; sols = </span>
<span class="comment">//     this-&gt;fesystem_controller.analysis_case-&gt;getSolutions();</span>

<span class="comment">//   std::vector&lt;Solution::SolutionBase*&gt;::const_iterator sol_it, sol_end;</span>
<span class="comment">//   sol_it = sols.begin();</span>
<span class="comment">//   sol_end = sols.end();</span>
  
<span class="comment">//   std::vector&lt;Solution::SolNameInfo&gt;::const_iterator sol_name_it, sol_name_end;</span>
<span class="comment">//   std::vector&lt;unsigned int&gt;::const_iterator lc_it, lc_end;</span>

<span class="comment">//   unsigned int n_nodal_variables = 0;</span>
  
<span class="comment">//   // iterate over all the solutions and write the nodal solution names for the </span>
<span class="comment">//   // load cases and DV sensitivities.</span>
<span class="comment">//   for ( ; sol_it != sol_end; sol_it++)</span>
<span class="comment">//     {</span>
<span class="comment">//     // if the solution does not have this discipline, nothing to be written.</span>
<span class="comment">//     if (! (*sol_it)-&gt;checkParticipatingDiscipline(Discipline::THERMAL_DISCIPLINE::num()))</span>
<span class="comment">//       continue;</span>

<span class="comment">//     // else, get the solution name and load cases from this solution</span>
<span class="comment">//     const std::vector&lt;Solution::SolNameInfo &gt;&amp; sol_names = </span>
<span class="comment">//       (*sol_it)-&gt;getNodalSolutionNames(Discipline::THERMAL_DISCIPLINE::num());</span>
    
<span class="comment">//     // iterate over all the solution names and write them to the output</span>
<span class="comment">//     sol_name_it = sol_names.begin();</span>
<span class="comment">//     sol_name_end = sol_names.end();</span>
    
<span class="comment">//     for (; sol_name_it != sol_name_end; sol_name_it++)</span>
<span class="comment">//       {</span>
<span class="comment">//       // get the load cases associated with this solution and write</span>
<span class="comment">//       // the names</span>
<span class="comment">//       lc_it = sol_name_it-&gt;load_cases.begin();</span>
<span class="comment">//       lc_end = sol_name_it-&gt;load_cases.end();</span>
      
<span class="comment">//       for ( ; lc_it != lc_end; lc_it++)</span>
<span class="comment">//         {</span>
<span class="comment">//         output &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; sol_name_it-&gt;sol_name &lt;&lt; &quot;_lc_&quot; &lt;&lt; *lc_it &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">//         n_nodal_variables++;</span>
<span class="comment">//         }</span>
      
<span class="comment">//       }</span>
<span class="comment">//     }</span>

<span class="comment">//   output &lt;&lt; &quot;\n&quot;;</span>

<span class="comment">//   // having written all the variable names, write the zones and actual variable values</span>
  
<span class="comment">//   // also, get the iterators to the elem_type map</span>
<span class="comment">//   std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt;::const_iterator elem_map_it, elem_map_end;</span>
<span class="comment">//   elem_map_it = this-&gt;elem_vec_map.begin();</span>
<span class="comment">//   elem_map_end = this-&gt;elem_vec_map.end();</span>
        
        
  
<span class="comment">//   std::string zone_name, elem_name;</span>
<span class="comment">//   for (; elem_map_it != elem_map_end; elem_map_it++)</span>
<span class="comment">//     {</span>
<span class="comment">//     zone_name.clear();</span>
<span class="comment">//     elem_name.clear();</span>
<span class="comment">//     switch (elem_map_it-&gt;first)</span>
<span class="comment">//       {</span>
<span class="comment">//       case QUAD4:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;QUAD ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FEQUADRILATERAL&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case EDGE2:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;EDGE ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FELINESEG&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case TRI3:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;TRI ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FETRIANGLE&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case HEX8:</span>
<span class="comment">//       case PRISM6:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;HEX8 ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FEBRICK&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       default:</span>
<span class="comment">//         abort();</span>
<span class="comment">//       }</span>
    
    
<span class="comment">//     if ( elem_map_it == this-&gt;elem_vec_map.begin())</span>
<span class="comment">//       {</span>
<span class="comment">//       output &lt;&lt; &quot;\n ZONE  T=\&quot;&quot; &lt;&lt;zone_name&lt;&lt; &quot;\&quot;, N=&quot; &lt;&lt; this-&gt;mesh-&gt;n_nodes() &lt;&lt; &quot;,  E=&quot; &lt;&lt; elem_map_it-&gt;second.size() </span>
<span class="comment">//       &lt;&lt; &quot;, DATAPACKING=BLOCK&quot;&lt;&lt; &quot;,  ZONETYPE=&quot;&lt;&lt; elem_name &lt;&lt; std::endl;</span>
<span class="comment">//       // and write the node data</span>
<span class="comment">//       // node data</span>
<span class="comment">//       output.setf(std::ios::showpoint);</span>
      
<span class="comment">//       std::ostringstream node_x, node_y, node_z;</span>
      
<span class="comment">//       // iterate over the nodes and write the data</span>
<span class="comment">//       for (unsigned int node_it=0; node_it &lt; this-&gt;mesh-&gt;n_nodes(); node_it++)</span>
<span class="comment">//         {</span>
<span class="comment">//            const Node* node = this-&gt;mesh_data-&gt;getNodeFromInternalID(node_it);</span>
              
<span class="comment">//            // write the x,y,z data and then write the temperature data for each node</span>
<span class="comment">//            node_x &lt;&lt; std::setprecision(8) &lt;&lt; (*node)(0) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//            node_y &lt;&lt; std::setprecision(8) &lt;&lt; (*node)(1) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//            node_z &lt;&lt; std::setprecision(8) &lt;&lt; (*node)(2) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//         }</span>
      
<span class="comment">//       node_x &lt;&lt; std::endl; </span>
<span class="comment">//       node_y &lt;&lt; std::endl;</span>
<span class="comment">//       node_z &lt;&lt; std::endl;</span>
      
<span class="comment">//       output &lt;&lt; node_x.str();</span>
<span class="comment">//       output &lt;&lt; node_y.str();</span>
<span class="comment">//       output &lt;&lt; node_z.str();</span>

<span class="comment">//       // get the iterators to the solutions</span>
<span class="comment">//       sol_it = sols.begin();</span>
<span class="comment">//       sol_end = sols.end();</span>
      
<span class="comment">//       // iterate over all the solutions and write the nodal solutions for the </span>
<span class="comment">//       // load cases</span>
<span class="comment">//       for ( ; sol_it != sol_end; sol_it++)</span>
<span class="comment">//         {</span>
<span class="comment">//         // if the solution does not have this discipline, nothing to be written.</span>
<span class="comment">//         if (! (*sol_it)-&gt;checkParticipatingDiscipline(Discipline::THERMAL_DISCIPLINE::num()))</span>
<span class="comment">//           continue;</span>
        
<span class="comment">//         // else, get the solution name and load cases from this solution</span>
<span class="comment">//         const std::vector&lt;Solution::SolNameInfo &gt;&amp; sol_names = </span>
<span class="comment">//           (*sol_it)-&gt;getNodalSolutionNames(Discipline::THERMAL_DISCIPLINE::num());</span>
        
<span class="comment">//         // iterate over all the solution names and write them to the output</span>
<span class="comment">//         sol_name_it = sol_names.begin();</span>
<span class="comment">//         sol_name_end = sol_names.end();</span>
        
<span class="comment">//         for (; sol_name_it != sol_name_end; sol_name_it++)</span>
<span class="comment">//           {</span>
<span class="comment">//           // get the load cases associated with this solution and write</span>
<span class="comment">//           // the names</span>
<span class="comment">//           lc_it = sol_name_it-&gt;load_cases.begin();</span>
<span class="comment">//           lc_end = sol_name_it-&gt;load_cases.end();</span>
          
<span class="comment">//           unsigned int dof=0;</span>
<span class="comment">//           for ( ; lc_it != lc_end; lc_it++)</span>
<span class="comment">//             {</span>
<span class="comment">//             // get the solution name in the database, fill the vector and write the variable</span>
<span class="comment">//             this-&gt;fesystem_controller.global_data_storage-&gt;fillVector(*lc_it,</span>
<span class="comment">//                                                                       sol_name_it-&gt;database_name,</span>
<span class="comment">//                                                                       *(vector.get()));</span>
            
<span class="comment">//             for (unsigned int node_it=0; node_it &lt; this-&gt;mesh-&gt;n_nodes(); node_it++)</span>
<span class="comment">//               {</span>
<span class="comment">//               dof = this-&gt;mesh_data-&gt;getNodeFromInternalID(node_it)-&gt;dof_number(0,0,0);</span>
<span class="comment">//               output &lt;&lt; std::setprecision(8) &lt;&lt; (*vector.get())(dof) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//               }</span>
<span class="comment">//             }</span>
<span class="comment">//           }</span>
<span class="comment">//         }</span>
<span class="comment">//       output &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<span class="comment">//       }</span>
<span class="comment">//     else</span>
<span class="comment">//       {</span>
<span class="comment">//       output &lt;&lt; &quot;\n ZONE  T=\&quot;&quot;&lt;&lt;zone_name&lt;&lt;&quot;\&quot;, N=&quot; &lt;&lt; this-&gt;mesh-&gt;n_nodes() &lt;&lt; &quot;,  E=&quot; &lt;&lt; elem_map_it-&gt;second.size() </span>
<span class="comment">//       &lt;&lt; &quot;, VARSHARELIST=([1-&quot; </span>
<span class="comment">//       &lt;&lt; 3 + n_nodal_variables</span>
<span class="comment">//       &lt;&lt;&quot;]=1)&quot;&lt;&lt; &quot;,  ZONETYPE=&quot;&lt;&lt; elem_name &lt;&lt; std::endl;</span>
<span class="comment">//       }</span>
          
<span class="comment">//     // element data</span>
<span class="comment">//     std::vector&lt;Elem*&gt;::const_iterator elem_it = elem_map_it-&gt;second.begin();</span>
<span class="comment">//     std::vector&lt;Elem*&gt;::const_iterator elem_end = elem_map_it-&gt;second.end();</span>
    
<span class="comment">//     unsigned int n_elem_nodes = 0;</span>
<span class="comment">//     for (; elem_it != elem_end; elem_it++)</span>
<span class="comment">//       {</span>
<span class="comment">//       n_elem_nodes = (*elem_it)-&gt;n_nodes();</span>
<span class="comment">//       const ElemType elemtype = (*elem_it)-&gt;type();</span>
<span class="comment">//       // for each node of the elem, find the node location in </span>
<span class="comment">//       // the map, and write the connectivity data</span>
<span class="comment">//       switch (elemtype)</span>
<span class="comment">//         {</span>
<span class="comment">//         case PRISM6:</span>
<span class="comment">//           {</span>
<span class="comment">//             for (unsigned int i=0; i&lt;n_elem_nodes; i++)</span>
<span class="comment">//               {</span>
<span class="comment">//               const Node* node = (*elem_it)-&gt;get_node(i);</span>
<span class="comment">//               output &lt;&lt; (this-&gt;mesh_data-&gt;getInternalIDFromNode(node)+1) &lt;&lt; &quot;  &quot; ;</span>
<span class="comment">//               if (i == 2 || i == 5)</span>
<span class="comment">//                 output &lt;&lt; (this-&gt;mesh_data-&gt;getInternalIDFromNode(node)+1) &lt;&lt; &quot;  &quot; ;</span>
<span class="comment">//               }</span>
<span class="comment">//           }</span>
<span class="comment">//           break;</span>
          
<span class="comment">//         default:</span>
<span class="comment">//           {</span>
<span class="comment">//             for (unsigned int i=0; i&lt;n_elem_nodes; i++)</span>
<span class="comment">//               {</span>
<span class="comment">//               const Node* node = (*elem_it)-&gt;get_node(i);</span>
<span class="comment">//               output &lt;&lt; (this-&gt;mesh_data-&gt;getInternalIDFromNode(node)+1) &lt;&lt; &quot;  &quot; ;</span>
<span class="comment">//               }</span>
<span class="comment">//           }</span>
<span class="comment">//           break;</span>
<span class="comment">//         }</span>
<span class="comment">//       }</span>
<span class="comment">//     output &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<span class="comment">//     }</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a088a7c5dfc89dd4a3bfc89ca2917ceb8"></a><!-- doxytag: member="TecPlotOutputProcessor::writeStructuralData" ref="a088a7c5dfc89dd4a3bfc89ca2917ceb8" args="(std::ostream &amp;output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tec_plot_output_processor.html#a088a7c5dfc89dd4a3bfc89ca2917ceb8">TecPlotOutputProcessor::writeStructuralData</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8_c_source.html#l00468">468</a> of file <a class="el" href="_tec_plot_output_processor_8_c_source.html">TecPlotOutputProcessor.C</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//   this-&gt;prepareElemTypeMap();</span>
  
<span class="comment">// //  PostProcessQtyDatabase&amp; database = </span>
<span class="comment">// //    (*this-&gt;fesystem_controller.post_process_qty_database.get());</span>
  
<span class="comment">//   // this is the vector in which the data will be obtained and then written from</span>
<span class="comment">//   std::auto_ptr&lt;NumericVector&lt;double&gt; &gt; vector</span>
<span class="comment">//     (NumericVector&lt;double&gt;::build().release()); </span>
  
<span class="comment">//   // also, get the iterators to the elem_type map</span>
<span class="comment">//   std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt;::const_iterator elem_map_it, elem_map_end;</span>
<span class="comment">//   elem_map_it = this-&gt;elem_vec_map.begin();</span>
<span class="comment">//   elem_map_end = this-&gt;elem_vec_map.end();</span>
        
<span class="comment">//   // control parameters</span>
<span class="comment">//   output  &lt;&lt; &quot;TITLE = \&quot; FESystem Output\&quot; &quot; &lt;&lt; &quot;\n&quot;</span>
<span class="comment">//     &lt;&lt; &quot;VARIABLES = \&quot;X\&quot;,  \&quot;Y\&quot;,  \&quot;Z\&quot;&quot;;</span>

<span class="comment">//   // iterate over each solution, and prepare a list of nodal and element centered </span>
<span class="comment">//   // variables for the same.</span>
<span class="comment">//   const std::vector&lt;Solution::SolutionBase*&gt; sols = </span>
<span class="comment">//     this-&gt;fesystem_controller.analysis_case-&gt;getSolutions();</span>
  
<span class="comment">//   std::vector&lt;Solution::SolutionBase*&gt;::const_iterator sol_it, sol_end;</span>
<span class="comment">//   sol_it = sols.begin();</span>
<span class="comment">//   sol_end = sols.end();</span>
  
<span class="comment">//   std::vector&lt;Solution::SolNameInfo&gt;::const_iterator sol_name_it, sol_name_end;</span>
<span class="comment">//   std::vector&lt;unsigned int&gt;::const_iterator lc_it, lc_end;</span>
  
<span class="comment">//   unsigned int n_nodal_variables = 0;</span>
  
<span class="comment">//   // iterate over all the solutions and write the nodal solution names for the </span>
<span class="comment">//   // load cases and DV sensitivities.</span>
<span class="comment">//   for ( ; sol_it != sol_end; sol_it++)</span>
<span class="comment">//     {</span>
<span class="comment">//     // if the solution does not have this discipline, nothing to be written.</span>
<span class="comment">//     if (! (*sol_it)-&gt;checkParticipatingDiscipline(Discipline::STRUCTURAL_DISCIPLINE::num()))</span>
<span class="comment">//       continue;</span>
    
<span class="comment">//     // else, get the solution name and load cases from this solution</span>
<span class="comment">//     const std::vector&lt;Solution::SolNameInfo &gt;&amp; sol_names = </span>
<span class="comment">//       (*sol_it)-&gt;getNodalSolutionNames(Discipline::STRUCTURAL_DISCIPLINE::num());</span>
    
<span class="comment">//     // iterate over all the solution names and write them to the output</span>
<span class="comment">//     sol_name_it = sol_names.begin();</span>
<span class="comment">//     sol_name_end = sol_names.end();</span>
    
<span class="comment">//     for (; sol_name_it != sol_name_end; sol_name_it++)</span>
<span class="comment">//       {</span>
<span class="comment">//       // get the load cases associated with this solution and write</span>
<span class="comment">//       // the names</span>
<span class="comment">//       lc_it = sol_name_it-&gt;load_cases.begin();</span>
<span class="comment">//       lc_end = sol_name_it-&gt;load_cases.end();</span>
      
<span class="comment">//       for ( ; lc_it != lc_end; lc_it++)</span>
<span class="comment">//         {</span>
<span class="comment">//         output &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; sol_name_it-&gt;sol_name &lt;&lt; &quot;_u_lc_&quot; &lt;&lt; *lc_it &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">//         output &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; sol_name_it-&gt;sol_name &lt;&lt; &quot;_v_lc_&quot; &lt;&lt; *lc_it &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">//         output &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; sol_name_it-&gt;sol_name &lt;&lt; &quot;_w_lc_&quot; &lt;&lt; *lc_it &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">//         output &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; sol_name_it-&gt;sol_name &lt;&lt; &quot;_theta_x_lc_&quot; &lt;&lt; *lc_it &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">//         output &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; sol_name_it-&gt;sol_name &lt;&lt; &quot;_theta_y_lc_&quot; &lt;&lt; *lc_it &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">//         output &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; sol_name_it-&gt;sol_name &lt;&lt; &quot;_theta_z_lc_&quot; &lt;&lt; *lc_it &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">//         n_nodal_variables += 6;</span>
<span class="comment">//         }</span>
      
<span class="comment">//       }</span>
<span class="comment">//     }</span>
  
<span class="comment">// //  for (unsigned int i=0; i&lt;load_cases.size(); i++)</span>
<span class="comment">// //    {</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;epsilon_xx_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;epsilon_yy_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;epsilon_xy_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;sigma_xx_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;sigma_yy_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;sigma_xy_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;strain_energy_density_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    output &lt;&lt; &quot;, \&quot;VonMises_lc_&quot; &lt;&lt; load_cases[i] &lt;&lt;  &quot;\&quot;&quot;;</span>
<span class="comment">// //    }</span>
<span class="comment">//   output &lt;&lt; &quot;\n&quot;;</span>
        
  
<span class="comment">//   std::string zone_name, elem_name;</span>
<span class="comment">//   for (; elem_map_it != elem_map_end; elem_map_it++)</span>
<span class="comment">//     {</span>
<span class="comment">//     zone_name.clear();</span>
<span class="comment">//     elem_name.clear();</span>
<span class="comment">//     switch (elem_map_it-&gt;first)</span>
<span class="comment">//       {</span>
<span class="comment">//       case QUAD4:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;QUAD ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FEQUADRILATERAL&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case EDGE2:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;EDGE ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FELINESEG&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case TRI3:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;TRI ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FETRIANGLE&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       case HEX8:</span>
<span class="comment">//       case PRISM6:</span>
<span class="comment">//         {</span>
<span class="comment">//           zone_name = &quot;HEX8 ELEMS&quot;;</span>
<span class="comment">//           elem_name = &quot;FEBRICK&quot;;</span>
<span class="comment">//         }</span>
<span class="comment">//         break;</span>
        
<span class="comment">//       default:</span>
<span class="comment">//         abort();</span>
<span class="comment">//       }</span>
    
<span class="comment">//     if ( elem_map_it == this-&gt;elem_vec_map.begin())</span>
<span class="comment">//       {</span>
<span class="comment">// //      output &lt;&lt; &quot;\n ZONE  T=\&quot;&quot;&lt;&lt;zone_name&lt;&lt;&quot;\&quot;, N=&quot; &lt;&lt; this-&gt;mesh-&gt;n_nodes() &lt;&lt; &quot;,  E=&quot; &lt;&lt; elem_map_it-&gt;second.size() </span>
<span class="comment">// //      &lt;&lt; &quot;, DATAPACKING=BLOCK&quot;&lt;&lt; &quot;, VARLOCATION=([1-&quot;</span>
<span class="comment">// //      &lt;&lt; 3+6*n_load_cases&lt;&lt;&quot;]=NODAL,[&quot;</span>
<span class="comment">// //      &lt;&lt; 3+6*n_load_cases+1&lt;&lt;&quot;-&quot;</span>
<span class="comment">// //      &lt;&lt; 3+(6+8)*n_load_cases&lt;&lt;&quot;]=CELLCENTERED)&quot; </span>
<span class="comment">// //      &lt;&lt; &quot;, ZONETYPE=&quot;&lt;&lt; elem_name &lt;&lt; std::endl;</span>

<span class="comment">//       output &lt;&lt; &quot;\n ZONE  T=\&quot;&quot;&lt;&lt;zone_name&lt;&lt;&quot;\&quot;, N=&quot; &lt;&lt; this-&gt;mesh-&gt;n_nodes() &lt;&lt; &quot;,  E=&quot; &lt;&lt; elem_map_it-&gt;second.size() </span>
<span class="comment">//       &lt;&lt; &quot;, DATAPACKING=BLOCK&quot;&lt;&lt; &quot;, VARLOCATION=([1-&quot;</span>
<span class="comment">//       &lt;&lt; 3+n_nodal_variables&lt;&lt;&quot;]=NODAL)&quot; </span>
<span class="comment">//       &lt;&lt; &quot;, ZONETYPE=&quot;&lt;&lt; elem_name &lt;&lt; std::endl;</span>
      
<span class="comment">//       // and write the node data</span>
<span class="comment">//       // node data</span>
<span class="comment">//       output.setf(std::ios::showpoint);</span>
      
<span class="comment">//       std::ostringstream node_x, node_y, node_z;</span>
      
<span class="comment">//       // iterate over the nodes and write the data</span>
<span class="comment">//       for (unsigned int node_it=0; node_it &lt; this-&gt;mesh-&gt;n_nodes(); node_it++)</span>
<span class="comment">//         {</span>
<span class="comment">//            const Node* node = this-&gt;mesh_data-&gt;getNodeFromInternalID(node_it);</span>
              
<span class="comment">//            // write the x,y,z data and then write the temperature data for each node</span>
<span class="comment">//            node_x &lt;&lt; std::setprecision(8) &lt;&lt; (*node)(0) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//            node_y &lt;&lt; std::setprecision(8) &lt;&lt; (*node)(1) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//            node_z &lt;&lt; std::setprecision(8) &lt;&lt; (*node)(2) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//         }</span>
      
<span class="comment">//       node_x &lt;&lt; std::endl; </span>
<span class="comment">//       node_y &lt;&lt; std::endl;</span>
<span class="comment">//       node_z &lt;&lt; std::endl;</span>
      
<span class="comment">//       output &lt;&lt; node_x.str();</span>
<span class="comment">//       output &lt;&lt; node_y.str();</span>
<span class="comment">//       output &lt;&lt; node_z.str();</span>
      
<span class="comment">//       // get the iterators to the solutions</span>
<span class="comment">//       sol_it = sols.begin();</span>
<span class="comment">//       sol_end = sols.end();</span>
      
<span class="comment">//       // iterate over all the solutions and write the nodal solutions for the </span>
<span class="comment">//       // load cases</span>
<span class="comment">//       for ( ; sol_it != sol_end; sol_it++)</span>
<span class="comment">//         {</span>
<span class="comment">//         // if the solution does not have this discipline, nothing to be written.</span>
<span class="comment">//         if (! (*sol_it)-&gt;checkParticipatingDiscipline(Discipline::STRUCTURAL_DISCIPLINE::num()))</span>
<span class="comment">//           continue;</span>
        
<span class="comment">//         // else, get the solution name and load cases from this solution</span>
<span class="comment">//         const std::vector&lt;Solution::SolNameInfo &gt;&amp; sol_names = </span>
<span class="comment">//           (*sol_it)-&gt;getNodalSolutionNames(Discipline::STRUCTURAL_DISCIPLINE::num());</span>
        
<span class="comment">//         // iterate over all the solution names and write them to the output</span>
<span class="comment">//         sol_name_it = sol_names.begin();</span>
<span class="comment">//         sol_name_end = sol_names.end();</span>
        
<span class="comment">//         for (; sol_name_it != sol_name_end; sol_name_it++)</span>
<span class="comment">//           {</span>
<span class="comment">//           // get the load cases associated with this solution and write</span>
<span class="comment">//           // the names</span>
<span class="comment">//           lc_it = sol_name_it-&gt;load_cases.begin();</span>
<span class="comment">//           lc_end = sol_name_it-&gt;load_cases.end();</span>
          
<span class="comment">//           unsigned int dof=0;</span>
<span class="comment">//           for ( ; lc_it != lc_end; lc_it++)</span>
<span class="comment">//             {</span>
<span class="comment">//             std::ostringstream u_var, v_var, w_var, theta_x_var, theta_y_var, theta_z_var;</span>

<span class="comment">//             // get the solution name in the database, fill the vector and write the variable</span>
<span class="comment">//             this-&gt;fesystem_controller.global_data_storage-&gt;fillVector(*lc_it,</span>
<span class="comment">//                                                                       sol_name_it-&gt;database_name,</span>
<span class="comment">//                                                                       *(vector.get()));</span>
            
<span class="comment">//             for (unsigned int node_it=0; node_it &lt; this-&gt;mesh-&gt;n_nodes(); node_it++)</span>
<span class="comment">//               {</span>
<span class="comment">//               for (unsigned int i=0; i&lt;6; i++)</span>
<span class="comment">//                 {</span>
<span class="comment">//                 dof = this-&gt;mesh_data-&gt;getNodeFromInternalID(node_it)-&gt;dof_number(0,i,0);</span>
<span class="comment">//                 switch (i)</span>
<span class="comment">//                   {</span>
<span class="comment">//                   case 0:</span>
<span class="comment">//                     u_var &lt;&lt; std::setprecision(8) &lt;&lt; (*vector.get())(dof) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//                     break;</span>
<span class="comment">//                   case 1:</span>
<span class="comment">//                     v_var &lt;&lt; std::setprecision(8) &lt;&lt; (*vector.get())(dof) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//                     break;</span>
<span class="comment">//                   case 2:</span>
<span class="comment">//                     w_var &lt;&lt; std::setprecision(8) &lt;&lt; (*vector.get())(dof) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//                     break;</span>
<span class="comment">//                   case 3:</span>
<span class="comment">//                     theta_x_var &lt;&lt; std::setprecision(8) &lt;&lt; (*vector.get())(dof) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//                     break;</span>
<span class="comment">//                   case 4:</span>
<span class="comment">//                     theta_y_var &lt;&lt; std::setprecision(8) &lt;&lt; (*vector.get())(dof) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//                     break;</span>
<span class="comment">//                   case 5:</span>
<span class="comment">//                     theta_z_var &lt;&lt; std::setprecision(8) &lt;&lt; (*vector.get())(dof) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">//                     break;</span>
<span class="comment">//                   default:</span>
<span class="comment">//                     abort();</span>
<span class="comment">//                     break;</span>
<span class="comment">//                   }</span>
<span class="comment">//                 }</span>
<span class="comment">//               }</span>
            
<span class="comment">//             output &lt;&lt; u_var.str() &lt;&lt; std::endl;</span>
<span class="comment">//             output &lt;&lt; v_var.str() &lt;&lt; std::endl;</span>
<span class="comment">//             output &lt;&lt; w_var.str() &lt;&lt; std::endl;</span>
<span class="comment">//             output &lt;&lt; theta_x_var.str() &lt;&lt; std::endl;</span>
<span class="comment">//             output &lt;&lt; theta_y_var.str() &lt;&lt; std::endl;</span>
<span class="comment">//             output &lt;&lt; theta_z_var.str() &lt;&lt; std::endl;</span>
<span class="comment">//             }</span>
<span class="comment">//           }</span>
<span class="comment">//         }</span>
<span class="comment">//       output &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<span class="comment">//       }</span>
<span class="comment">//     else</span>
<span class="comment">//       {</span>
<span class="comment">// //      output &lt;&lt; &quot;\n ZONE  T=\&quot;&quot;&lt;&lt; zone_name &lt;&lt; &quot;\&quot;, N=&quot; &lt;&lt; this-&gt;mesh-&gt;n_nodes() &lt;&lt; &quot;,  E=&quot; &lt;&lt; elem_map_it-&gt;second.size() </span>
<span class="comment">// //      &lt;&lt; &quot;, DATAPACKING=BLOCK&quot;&lt;&lt; &quot;, VARLOCATION=([1-&quot;</span>
<span class="comment">// //      &lt;&lt; 3+6*n_load_cases&lt;&lt;&quot;]=NODAL,[&quot;</span>
<span class="comment">// //      &lt;&lt; 3+6*n_load_cases+1&lt;&lt;&quot;-&quot;</span>
<span class="comment">// //      &lt;&lt; 3+(6+8)*n_load_cases&lt;&lt;&quot;]=CELLCENTERED)&quot; </span>
<span class="comment">// //      &lt;&lt; &quot;, DATAPACKING=BLOCK&quot; </span>
<span class="comment">// //      &lt;&lt;  &quot;, VARSHARELIST=([1-&quot;</span>
<span class="comment">// //      &lt;&lt; 3+6*n_load_cases &lt;&lt; &quot;]=1)&quot;&lt;&lt; &quot;,  ZONETYPE=&quot; &lt;&lt; elem_name &lt;&lt;&quot; \n&quot;;</span>
<span class="comment">//       output &lt;&lt; &quot;\n ZONE  T=\&quot;&quot;&lt;&lt; zone_name &lt;&lt; &quot;\&quot;, N=&quot; &lt;&lt; this-&gt;mesh-&gt;n_nodes() &lt;&lt; &quot;,  E=&quot; &lt;&lt; elem_map_it-&gt;second.size() </span>
<span class="comment">//       &lt;&lt; &quot;, DATAPACKING=BLOCK&quot;&lt;&lt; &quot;, VARLOCATION=([1-&quot;</span>
<span class="comment">//       &lt;&lt; 3+n_nodal_variables&lt;&lt;&quot;]=NODAL)&quot; </span>
<span class="comment">//       &lt;&lt; &quot;, DATAPACKING=BLOCK&quot; </span>
<span class="comment">//       &lt;&lt;  &quot;, VARSHARELIST=([1-&quot;</span>
<span class="comment">//       &lt;&lt; 3+n_nodal_variables &lt;&lt; &quot;]=1)&quot;&lt;&lt; &quot;,  ZONETYPE=&quot; &lt;&lt; elem_name &lt;&lt;&quot; \n&quot;;</span>
<span class="comment">//       }</span>
          
<span class="comment">// //    // write the element dependent variables</span>
<span class="comment">// //    unsigned int elem_ID;</span>
<span class="comment">// //    lc_it = load_cases.begin();</span>
<span class="comment">// //    for ( ; lc_it != lc_end; lc_it++)</span>
<span class="comment">// //      {</span>
<span class="comment">// //      std::ostringstream lc_num;</span>
<span class="comment">// //      lc_num &lt;&lt; *lc_it;</span>
<span class="comment">// //       </span>
<span class="comment">// //      std::ostringstream </span>
<span class="comment">// //        stream_vector_0, stream_vector_1, stream_vector_2, stream_vector_3, </span>
<span class="comment">// //        stream_vector_4, stream_vector_5, stream_vector_6, stream_vector_7;</span>
<span class="comment">// //      </span>
<span class="comment">// //      // get the iterator for the elems</span>
<span class="comment">// //      std::vector&lt;Elem*&gt;::const_iterator elem_it = elem_map_it-&gt;second.begin();</span>
<span class="comment">// //      std::vector&lt;Elem*&gt;::const_iterator elem_end = elem_map_it-&gt;second.end();</span>
<span class="comment">// //      </span>
<span class="comment">// //      std::set&lt;Elem*&gt;::const_iterator dummy_elem_end =</span>
<span class="comment">// //        this-&gt;dummy_elem_set-&gt;end();</span>
<span class="comment">// //       </span>
<span class="comment">// //      for (; elem_it != elem_end; elem_it++)</span>
<span class="comment">// //        {</span>
<span class="comment">// //         Elem* elem = *elem_it;</span>
<span class="comment">// //        </span>
<span class="comment">// //         if (this-&gt;dummy_elem_set-&gt;find(elem) != dummy_elem_end)</span>
<span class="comment">// //          continue;</span>
<span class="comment">// //        </span>
<span class="comment">// //        </span>
<span class="comment">// //         elem_ID = this-&gt;mesh_data-&gt;getForeignIDFromElem(elem);</span>
<span class="comment">// //        </span>
<span class="comment">// //         ElemPostProcessQty&amp; qty =  </span>
<span class="comment">// //          dynamic_cast&lt;ElemPostProcessQty&amp;&gt;(database.getElementPostProcessQty</span>
<span class="comment">// //                                            (Discipline::STRUCTURAL_DISCIPLINE::num(),</span>
<span class="comment">// //                                             elem_ID));</span>
<span class="comment">// //        </span>
<span class="comment">// //         // get the strain and stress tensor</span>
<span class="comment">// //         TensorValue&lt;double&gt;&amp; strain = qty.getStrainTensor(*lc_it);</span>
<span class="comment">// //         TensorValue&lt;double&gt;&amp; stress = qty.getStressTensor(*lc_it);</span>
<span class="comment">// //        </span>
<span class="comment">// //         // write the values to the streams</span>
<span class="comment">// //         stream_vector_0 &lt;&lt; strain(0,0) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">// //         stream_vector_1 &lt;&lt; strain(1,1) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">// //         stream_vector_2 &lt;&lt; strain(0,1) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">// //        </span>
<span class="comment">// //         stream_vector_3 &lt;&lt; stress(0,0) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">// //         stream_vector_4 &lt;&lt; stress(1,1) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">// //         stream_vector_5 &lt;&lt; stress(0,1) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">// //        </span>
<span class="comment">// //         stream_vector_6 &lt;&lt; qty.getStrainEnergyDensity(*lc_it) &lt;&lt; &quot;  &quot;;</span>
<span class="comment">// //         stream_vector_7 &lt;&lt; qty.getVonMisesStress(*lc_it) &lt;&lt; &quot;  &quot; ;</span>
<span class="comment">// //        }  </span>
<span class="comment">// //       </span>
<span class="comment">// //      // now write the variables to the output</span>
<span class="comment">// //      output &lt;&lt; stream_vector_0.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      output &lt;&lt; stream_vector_1.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      output &lt;&lt; stream_vector_2.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      output &lt;&lt; stream_vector_3.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      output &lt;&lt; stream_vector_4.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      output &lt;&lt; stream_vector_5.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      output &lt;&lt; stream_vector_6.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      output &lt;&lt; stream_vector_7.str() &lt;&lt; std::endl;</span>
<span class="comment">// //      }</span>
    
<span class="comment">//        // element data</span>
<span class="comment">//        std::vector&lt;Elem*&gt;::const_iterator elem_it = elem_map_it-&gt;second.begin();</span>
<span class="comment">//        std::vector&lt;Elem*&gt;::const_iterator elem_end = elem_map_it-&gt;second.end();</span>
          
<span class="comment">//        unsigned int n_elem_nodes = 0;</span>
<span class="comment">//        for (; elem_it != elem_end; elem_it++)</span>
<span class="comment">//          {</span>
<span class="comment">//       n_elem_nodes = (*elem_it)-&gt;n_nodes();</span>
<span class="comment">//       const ElemType elemtype = (*elem_it)-&gt;type();</span>
<span class="comment">//       // for each node of the elem, find the node location in </span>
<span class="comment">//       // the map, and write the connectivity data</span>
<span class="comment">//       switch (elemtype)</span>
<span class="comment">//         {</span>
<span class="comment">//         case PRISM6:</span>
<span class="comment">//           {</span>
<span class="comment">//             for (unsigned int i=0; i&lt;n_elem_nodes; i++)</span>
<span class="comment">//               {</span>
<span class="comment">//               const Node* node = (*elem_it)-&gt;get_node(i);</span>
<span class="comment">//               output &lt;&lt; (this-&gt;mesh_data-&gt;getInternalIDFromNode(node) + 1) &lt;&lt; &quot;  &quot; ;</span>
<span class="comment">//               if (i == 2 || i == 5)</span>
<span class="comment">//                 output &lt;&lt; (this-&gt;mesh_data-&gt;getInternalIDFromNode(node) + 1) &lt;&lt; &quot;  &quot; ;</span>
<span class="comment">//               }</span>
<span class="comment">//           }</span>
<span class="comment">//           break;</span>
          
<span class="comment">//         default:</span>
<span class="comment">//           {</span>
<span class="comment">//             for (unsigned int i=0; i&lt;n_elem_nodes; i++)</span>
<span class="comment">//               {</span>
<span class="comment">//               const Node* node = (*elem_it)-&gt;get_node(i);</span>
<span class="comment">//               output &lt;&lt; (this-&gt;mesh_data-&gt;getInternalIDFromNode(node) + 1) &lt;&lt; &quot;  &quot; ;</span>
<span class="comment">//               }</span>
<span class="comment">//           }</span>
<span class="comment">//           break;</span>
<span class="comment">//         }</span>
<span class="comment">//          }</span>
<span class="comment">//        output &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<span class="comment">//     }</span>
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af3a612f6c014b3ce04535d6bf43c3e0e"></a><!-- doxytag: member="TecPlotOutputProcessor::dummy_elem_set" ref="af3a612f6c014b3ce04535d6bf43c3e0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;Elem*&gt;* <a class="el" href="class_tec_plot_output_processor.html#af3a612f6c014b3ce04535d6bf43c3e0e">TecPlotOutputProcessor::dummy_elem_set</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8h_source.html#l00076">76</a> of file <a class="el" href="_tec_plot_output_processor_8h_source.html">TecPlotOutputProcessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a01d6d96d0373e10575ad2a9bf985c3bd"></a><!-- doxytag: member="TecPlotOutputProcessor::elem_vec_map" ref="a01d6d96d0373e10575ad2a9bf985c3bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;ElemType, std::vector&lt;Elem*&gt; &gt; <a class="el" href="class_tec_plot_output_processor.html#a01d6d96d0373e10575ad2a9bf985c3bd">TecPlotOutputProcessor::elem_vec_map</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8h_source.html#l00077">77</a> of file <a class="el" href="_tec_plot_output_processor_8h_source.html">TecPlotOutputProcessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd9541679ab178b17b4f679e86d4fcd"></a><!-- doxytag: member="TecPlotOutputProcessor::mesh" ref="a8bd9541679ab178b17b4f679e86d4fcd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mesh_d_s_1_1_f_e_mesh.html">MeshDS::FEMesh</a>* <a class="el" href="class_tec_plot_output_processor.html#a8bd9541679ab178b17b4f679e86d4fcd">TecPlotOutputProcessor::mesh</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8h_source.html#l00074">74</a> of file <a class="el" href="_tec_plot_output_processor_8h_source.html">TecPlotOutputProcessor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac112b1d13ee3be674a9b36df4f5c43dc"></a><!-- doxytag: member="TecPlotOutputProcessor::mesh_data" ref="ac112b1d13ee3be674a9b36df4f5c43dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mesh_d_s_1_1_f_e_mesh_data.html">MeshDS::FEMeshData</a>* <a class="el" href="class_tec_plot_output_processor.html#ac112b1d13ee3be674a9b36df4f5c43dc">TecPlotOutputProcessor::mesh_data</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_tec_plot_output_processor_8h_source.html#l00075">75</a> of file <a class="el" href="_tec_plot_output_processor_8h_source.html">TecPlotOutputProcessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/manav/Documents/codes/FESystemOld/FESystem/src/OutputProcessor/<a class="el" href="_tec_plot_output_processor_8h_source.html">TecPlotOutputProcessor.h</a></li>
<li>/Users/manav/Documents/codes/FESystemOld/FESystem/src/OutputProcessor/<a class="el" href="_tec_plot_output_processor_8_c_source.html">TecPlotOutputProcessor.C</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 12 2012 18:06:21 for fesystem by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
