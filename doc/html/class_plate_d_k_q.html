<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>fesystem: PlateDKQ Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">fesystem
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">PlateDKQ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="PlateDKQ" -->
<p><code>#include &lt;<a class="el" href="_plate_d_k_q_8h_source.html">PlateDKQ.h</a>&gt;</code></p>

<p><a href="class_plate_d_k_q-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plate_d_k_q.html#a9e698a50899014a0ed6c008bff2425cd">PlateDKQ</a> (const unsigned int, const Elem *, AnalysisDriver *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plate_d_k_q.html#a112d86fffbd946725e8d1a7e4f8d329a">~PlateDKQ</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="class_elem_post_process_qty.html">ElemPostProcessQty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plate_d_k_q.html#a0bf3e67479bf5a7d06ddd4c6afd4028f">getElementPostProcessQty</a> (std::vector&lt; unsigned int &gt;, std::vector&lt; <a class="el" href="class_design_data_1_1_design_parameter.html">DesignData::DesignParameter</a> * &gt;)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plate_d_k_q.html#a108bacf150462c96211d1f1f1af7efcb">calculate_M</a> (DenseMatrix&lt; double &gt; *, bool sensitivity_calculation=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plate_d_k_q.html#a3036e74ae9235ab4aa23b5e4d80e2968">calculate_K</a> (DenseMatrix&lt; double &gt; *, bool sensitivity_calculation=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plate_d_k_q.html#aec0a7e98a8433297dc73a4d6be2d29a1">calculate_F_T</a> (DenseVector&lt; double &gt; *, bool sensitivity_calculation=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plate_d_k_q.html#a86758dc3b8b18443e1bb814a09449328">calculateShearStiffnessFactor</a> (DenseMatrix&lt; double &gt; *matrix)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>a class definig the spring structural element </p>

<p>Definition at line <a class="el" href="_plate_d_k_q_8h_source.html#l00017">17</a> of file <a class="el" href="_plate_d_k_q_8h_source.html">PlateDKQ.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9e698a50899014a0ed6c008bff2425cd"></a><!-- doxytag: member="PlateDKQ::PlateDKQ" ref="a9e698a50899014a0ed6c008bff2425cd" args="(const unsigned int, const Elem *, AnalysisDriver *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_plate_d_k_q.html#a9e698a50899014a0ed6c008bff2425cd">PlateDKQ::PlateDKQ</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>elem_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Elem *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnalysisDriver *&#160;</td>
          <td class="paramname"><em>analysis_driver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_plate_d_k_q_8_c_source.html#l00016">16</a> of file <a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a>.</p>
<div class="fragment"><pre class="fragment">                                                       :
  StructuralElem(elem_ID,elem,analysis_driver)
{
  assert(elem-&gt;type() == QUAD4);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a112d86fffbd946725e8d1a7e4f8d329a"></a><!-- doxytag: member="PlateDKQ::~PlateDKQ" ref="a112d86fffbd946725e8d1a7e4f8d329a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_plate_d_k_q.html#a112d86fffbd946725e8d1a7e4f8d329a">PlateDKQ::~PlateDKQ</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_plate_d_k_q_8_c_source.html#l00028">28</a> of file <a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a>.</p>
<div class="fragment"><pre class="fragment">{
        
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aec0a7e98a8433297dc73a4d6be2d29a1"></a><!-- doxytag: member="PlateDKQ::calculate_F_T" ref="aec0a7e98a8433297dc73a4d6be2d29a1" args="(DenseVector&lt; double &gt; *, bool sensitivity_calculation=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_plate_d_k_q.html#aec0a7e98a8433297dc73a4d6be2d29a1">PlateDKQ::calculate_F_T</a> </td>
          <td>(</td>
          <td class="paramtype">DenseVector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sensitivity_calculation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_plate_d_k_q_8_c_source.html#l00466">466</a> of file <a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a>.</p>
<div class="fragment"><pre class="fragment">{
  PropertyCard&amp; elem_property = *(this-&gt;_elem_property_card);
  Property::PropertyName prpty_name = Property::INVALID_PROPERTY_NAME;
        
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> load_case_num = this-&gt;analysis_driver-&gt;getCurrentLoadCase();
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_nodes = this-&gt;base_elem-&gt;n_nodes();

  <span class="comment">// initialize the data structures for the load</span>
  DenseVector&lt;double&gt; nodal_temp(n_nodes), nodal_temp_sens(n_nodes);

  <span class="comment">// get the loads for this element</span>
  this-&gt;getNodalTemperatureVector(nodal_temp, load_case_num);
  
  <span class="comment">// if sensitivity is being asked for, then get the iterators for the</span>
  <span class="comment">// sensitivity load vector</span>
  <span class="keywordflow">if</span> (sensitivity_calculation == <span class="keyword">true</span>)
    {
      <span class="keywordflow">switch</span> (this-&gt;DV-&gt;type())
        {
        <span class="keywordflow">case</span> PROPERTY_DV:
          prpty_name = (<span class="keyword">dynamic_cast&lt;</span>PropertyDesignVariable*<span class="keyword">&gt;</span>(this-&gt;DV))-&gt;propertyName();
          <span class="keywordflow">break</span>;
                                
        <span class="keywordflow">case</span> SHAPE_DV:
          <span class="keywordflow">break</span>;
                                
        <span class="keywordflow">default</span>:
          abort();
          <span class="keywordflow">break</span>;
        }
                
      <span class="comment">// get the load sensitivity vectors</span>
      this-&gt;getNodalTemperatureVector(nodal_temp_sens, load_case_num, <span class="keyword">true</span>, this-&gt;DV-&gt;ID());
    }

        
  <span class="keywordtype">double</span> E = elem_property[Property::E_11];
  <span class="keywordtype">double</span> h = elem_property[Property::THICKNESS];
  <span class="keywordtype">double</span> nu = elem_property[Property::NU];
  <span class="keywordtype">double</span> alpha = elem_property[Property::ALPHA_EXPANSION];
  <span class="keywordtype">double</span> ref_temp = this-&gt;analysis_discipline.getFESystemController().
    analysis_case-&gt;getRealParameter(<span class="stringliteral">&quot;REFERENCE_TEMP&quot;</span>);
        
  <span class="keywordtype">double</span> factor = 0.0, factor_sens = 0.0;
        
  factor = E*h*alpha/(1.0-nu);
 
  <span class="keywordflow">switch</span> (prpty_name)
    {
    <span class="keywordflow">case</span> Property::E_11:
      factor_sens = h*alpha/(1.0-nu);
      <span class="keywordflow">break</span>;
                        
    <span class="keywordflow">case</span> Property::THICKNESS:
      factor_sens = E*alpha/(1.0-nu);
      <span class="keywordflow">break</span>;
                        
    <span class="keywordflow">case</span> Property::NU:
      factor_sens = E*h*alpha/pow((1.0-nu),2);
      <span class="keywordflow">break</span>;
                        
    <span class="keywordflow">case</span> Property::ALPHA_EXPANSION:
      factor_sens = E*h/(1.0-nu);
      <span class="keywordflow">break</span>;
  
    <span class="keywordflow">default</span>:
      factor_sens = 0.0;
      <span class="keywordflow">break</span>;
    }
  
  <span class="comment">// get the factors necessary for calculation of the load vector</span>
  
  
  <span class="keywordflow">if</span> (sensitivity_calculation == <span class="keyword">true</span>)
    {
      <span class="comment">// the reference temperature is assumed to be constant</span>
      <span class="keywordflow">switch</span>(this-&gt;DV-&gt;type())
        {
        <span class="keywordflow">case</span> PROPERTY_DV:
          {
            DenseMatrix&lt;double&gt; nx_n_matrix(n_nodes,n_nodes), 
              ny_n_matrix(n_nodes,n_nodes);

            this-&gt;getFactor(&amp;nx_n_matrix, StructuralElem::N_X_N_FACTOR);
            this-&gt;getFactor(&amp;ny_n_matrix, StructuralElem::N_Y_N_FACTOR);

            <span class="keywordtype">double</span> sum1 = 0.0, sum2 = 0.0;
            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_nodes; i++)
              {
                sum1 = 0.0; sum2 = 0.0;
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;n_nodes; j++)
                  {
                    sum1 += nx_n_matrix(i,j) * (factor* (nodal_temp(j)-ref_temp) + factor_sens * nodal_temp_sens(j));
                    sum2 += ny_n_matrix(i,j) * (factor* (nodal_temp(j)-ref_temp) + factor_sens * nodal_temp_sens(j));
                  }
                (*vector)(i) = sum1;
                (*vector)(n_nodes + i) = sum2;
              }
          }
          <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> SHAPE_DV:
          {       
            DenseMatrix&lt;double&gt; nx_n_matrix(n_nodes,n_nodes), 
              ny_n_matrix(n_nodes,n_nodes), 
              nx_n_matrix_sens(n_nodes,n_nodes), 
              ny_n_matrix_sens(n_nodes,n_nodes);

            this-&gt;getFactor(&amp;nx_n_matrix, StructuralElem::N_X_N_FACTOR);
            this-&gt;getFactor(&amp;ny_n_matrix, StructuralElem::N_Y_N_FACTOR);
            this-&gt;getFactorShapeSensitivity(&amp;nx_n_matrix_sens, StructuralElem::N_X_N_FACTOR);
            this-&gt;getFactorShapeSensitivity(&amp;ny_n_matrix_sens, StructuralElem::N_Y_N_FACTOR);
            
            <span class="keywordtype">double</span> sum1 = 0.0, sum2 = 0.0;
            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_nodes; i++)
              {
                sum1 = 0.0; sum2 = 0.0;
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;n_nodes; j++)
                  {
                    sum1 += factor* ( nx_n_matrix_sens(i,j) * (nodal_temp(j)-ref_temp) + 
                                      nx_n_matrix(i,j) * nodal_temp_sens(j));
                    sum2 += factor* ( ny_n_matrix_sens(i,j) * (nodal_temp(j)-ref_temp) + 
                                      ny_n_matrix(i,j) * nodal_temp_sens(j));
                  }
                (*vector)(i) = sum1;
                (*vector)(n_nodes + i) = sum2;
              }

          }
          <span class="keywordflow">break</span>;

        <span class="keywordflow">default</span>:
          abort();
          <span class="keywordflow">break</span>;
        }
    }
  <span class="keywordflow">else</span> 
    {
      DenseMatrix&lt;double&gt; nx_n_matrix(n_nodes,n_nodes), 
        ny_n_matrix(n_nodes,n_nodes);

      this-&gt;getFactor(&amp;nx_n_matrix, StructuralElem::N_X_N_FACTOR);
      this-&gt;getFactor(&amp;ny_n_matrix, StructuralElem::N_Y_N_FACTOR);

      <span class="keywordtype">double</span> sum1 = 0.0, sum2 = 0.0;
      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_nodes; i++)
        {
          sum1 = 0.0; sum2 = 0.0;
          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;n_nodes; j++)
            {
              sum1 += nx_n_matrix(i,j) * (factor* (nodal_temp(j)-ref_temp));
              sum2 += ny_n_matrix(i,j) * (factor* (nodal_temp(j)-ref_temp));
            }
          (*vector)(i) = sum1;
          (*vector)(n_nodes + i) = sum2;
        }

    }
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3036e74ae9235ab4aa23b5e4d80e2968"></a><!-- doxytag: member="PlateDKQ::calculate_K" ref="a3036e74ae9235ab4aa23b5e4d80e2968" args="(DenseMatrix&lt; double &gt; *, bool sensitivity_calculation=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_plate_d_k_q.html#a3036e74ae9235ab4aa23b5e4d80e2968">PlateDKQ::calculate_K</a> </td>
          <td>(</td>
          <td class="paramtype">DenseMatrix&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sensitivity_calculation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_plate_d_k_q_8_c_source.html#l00050">50</a> of file <a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a>.</p>
<div class="fragment"><pre class="fragment">{
  Property::PropertyName prpty_name = Property::INVALID_PROPERTY_NAME;
        
  <span class="keywordflow">if</span> (sensitivity_calculation == <span class="keyword">true</span>)
    {
      <span class="keywordflow">switch</span> (this-&gt;DV-&gt;type())
        {
        <span class="keywordflow">case</span> PROPERTY_DV:
          prpty_name = (<span class="keyword">dynamic_cast&lt;</span>PropertyDesignVariable*<span class="keyword">&gt;</span>(this-&gt;DV))-&gt;propertyName();
          <span class="keywordflow">break</span>;
                                
        <span class="keywordflow">case</span> SHAPE_DV:
          <span class="keywordflow">break</span>;
                                
        <span class="keywordflow">default</span>:
          abort();
          <span class="keywordflow">break</span>;
        }
    }
        
        
  PropertyCard&amp; elem_property = *(this-&gt;_elem_property_card);
        
  <span class="keywordtype">double</span> E = elem_property[Property::E_11];
  <span class="keywordtype">double</span> h = elem_property[Property::THICKNESS];
  <span class="keywordtype">double</span> nu = elem_property[Property::NU];
        
  <span class="keyword">const</span> <span class="keywordtype">double</span> k = 5.0/6.0;
        
  <span class="keywordtype">double</span> Eh_nu2, Eh_nu, Ehnu_nu2, Eh3_12nu2, Eh3_12nu, Eh3nu_12nu2, Ehk_2nu;
        
  <span class="keywordflow">switch</span> (prpty_name)
    {
    <span class="keywordflow">case</span> Property::INVALID_PROPERTY_NAME:
      Eh_nu2 = E*h/(1.0-nu*nu);
      Eh_nu = E*h/(1.0+nu);
      Ehnu_nu2 = E*nu*h/(1.0-nu*nu);
      Eh3_12nu2 = E*h*h*h/12.0/(1.0-nu*nu);
      Eh3_12nu = E*h*h*h/12.0/(1.0+nu);
      Eh3nu_12nu2 = E*nu*h*h*h/12.0/(1.0-nu*nu);
      Ehk_2nu = E*h*k/2.0/(1.0+nu);
      <span class="keywordflow">break</span>;
                        
    <span class="keywordflow">case</span> Property::E_11:
      Eh_nu2 = h/(1.0-nu*nu);
      Eh_nu = h/(1.0+nu);
      Ehnu_nu2 = nu*h/(1.0-nu*nu);
      Eh3_12nu2 = h*h*h/12.0/(1.0-nu*nu);
      Eh3_12nu = h*h*h/12.0/(1.0+nu);
      Eh3nu_12nu2 = nu*h*h*h/12.0/(1.0-nu*nu);
      Ehk_2nu = h*k/2.0/(1.0+nu);
      <span class="keywordflow">break</span>;
                        
    <span class="keywordflow">case</span> Property::THICKNESS:
      Eh_nu2 = E/(1.0-nu*nu);
      Eh_nu = E/(1.0+nu);
      Ehnu_nu2 = E*nu/(1.0-nu*nu);
      Eh3_12nu2 = E*h*h/4.0/(1.0-nu*nu);
      Eh3_12nu = E*h*h/4.0/(1.0+nu);
      Eh3nu_12nu2 = E*nu*h*h/4.0/(1.0-nu*nu);
      Ehk_2nu = E*k/2.0/(1.0+nu);
      <span class="keywordflow">break</span>;
                        
    <span class="keywordflow">case</span> Property::NU:
      Eh_nu2 = 2.0*E*h*nu/(1.0-nu*nu)/(1.0-nu*nu);
      Eh_nu = -E*h/(1.0+nu)/(1.0+nu);
      Ehnu_nu2 = E*h*(1.0+nu*nu)/(1.0-nu*nu)/(1.0-nu*nu);
      Eh3_12nu = E*h*h*h*nu/6.0/(1.0-nu*nu)/(1.0-nu*nu);
      Eh3_12nu2 = -E*h*h*h/12.0/(1.0+nu)/(1.0+nu);
      Eh3nu_12nu2 = E*h*h*h*(1.0+nu*nu)/12.0/(1.0-nu*nu)*(1.0-nu*nu);
      Ehk_2nu = -E*h*k/2.0/(1.0+nu)/(1.0+nu);
      <span class="keywordflow">break</span>;
                        
    <span class="keywordflow">default</span>:
      Eh_nu2 = 0.0;
      Eh_nu = 0.0;
      Ehnu_nu2 = 0.0;
      Eh3_12nu = 0.0;
      Eh3_12nu2 = 0.0;
      Eh3nu_12nu2 = 0.0;
      Ehk_2nu = 0.0;
      <span class="keywordflow">break</span>;
    }
        
        
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_nodes = this-&gt;base_elem-&gt;n_nodes();
        
  std::auto_ptr&lt;DenseMatrix&lt;double&gt; &gt; shear_stiff(<span class="keyword">new</span> DenseMatrix&lt;double&gt;());
  this-&gt;resizeQty(shear_stiff.get());
        
  DenseMatrix&lt;double&gt; Nx_Nx(n_nodes,n_nodes),
    Ny_Ny(n_nodes,n_nodes),
    Nx_Ny(n_nodes,n_nodes);
        
        
  <span class="keywordflow">if</span> (sensitivity_calculation == <span class="keyword">false</span> || ( sensitivity_calculation == <span class="keyword">true</span> &amp;&amp; this-&gt;DV-&gt;type() == PROPERTY_DV))
    {
      this-&gt;getFactor(&amp;Nx_Nx, StructuralElem::N_X_N_X_FACTOR);
      this-&gt;getFactor(&amp;Ny_Ny, StructuralElem::N_Y_N_Y_FACTOR);
      this-&gt;getFactor(&amp;Nx_Ny, StructuralElem::N_X_N_Y_FACTOR);
      this-&gt;getFactor(shear_stiff.get(), StructuralElem::PLATE_QUAD4_SHEAR_STIFF_FACTOR);
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sensitivity_calculation == <span class="keyword">true</span> &amp;&amp; this-&gt;DV-&gt;type() == SHAPE_DV)
    {
      this-&gt;getFactorShapeSensitivity(&amp;Nx_Nx, StructuralElem::N_X_N_X_FACTOR);
      this-&gt;getFactorShapeSensitivity(&amp;Ny_Ny, StructuralElem::N_Y_N_Y_FACTOR);
      this-&gt;getFactorShapeSensitivity(&amp;Nx_Ny, StructuralElem::N_X_N_Y_FACTOR);
      this-&gt;getFactorShapeSensitivity(shear_stiff.get(), StructuralElem::PLATE_QUAD4_SHEAR_STIFF_FACTOR);
    }

        
  <span class="comment">// calculate the stiffness matrix</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_nodes; i++)
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;n_nodes; j++)
      {
        (*matrix)(i,j) += (Eh_nu2*Nx_Nx(i,j) + .5*Eh_nu* Ny_Ny(i,j));
        (*matrix)(n_nodes+i,j) += (Ehnu_nu2 * Nx_Ny(j,i) + .5*Eh_nu * Nx_Ny(i,j));
        (*matrix)(i,n_nodes+j) += (Ehnu_nu2 * Nx_Ny(i,j) + .5*Eh_nu * Nx_Ny(j,i));
        (*matrix)(n_nodes+i,n_nodes+j) += (Eh_nu2*Ny_Ny(i,j) + .5*Eh_nu* Nx_Nx(i,j));
        
        (*matrix)(3*n_nodes+i,3*n_nodes+j) += (Eh3_12nu2*Ny_Ny(i,j) + .5*Eh3_12nu* Nx_Nx(i,j));
        (*matrix)(4*n_nodes+i,3*n_nodes+j) += -(Eh3nu_12nu2*Nx_Ny(i,j) + .5*Eh3_12nu* Nx_Ny(j,i));
        (*matrix)(3*n_nodes+i,4*n_nodes+j) += -(Eh3nu_12nu2*Nx_Ny(j,i) + .5*Eh3_12nu* Nx_Ny(i,j));
        (*matrix)(4*n_nodes+i,4*n_nodes+j) += (Eh3_12nu2*Nx_Nx(i,j) + .5*Eh3_12nu* Ny_Ny(i,j));
      }
        
  <span class="comment">// now add the effects of the shear strains</span>
  shear_stiff-&gt;scale(Ehk_2nu);
  matrix-&gt;add(1.0, *(shear_stiff.get()));
                
  <span class="comment">//  std::cout &lt;&lt; *(shear_stiff.get()) &lt;&lt; std::endl;</span>

  <span class="comment">// finally, place a unity at the diagonal for the theta_z rows, to remove singularity </span>
  <span class="comment">// of the element</span>
  <span class="comment">// this will be changed in future, since the value of this fictitious stiffness is dependent on the </span>
  <span class="comment">// value of the other diagonal terms </span>
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;4; i++)
    (*matrix)(5*n_nodes+i,5*n_nodes+i) = 1.0;

  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a108bacf150462c96211d1f1f1af7efcb"></a><!-- doxytag: member="PlateDKQ::calculate_M" ref="a108bacf150462c96211d1f1f1af7efcb" args="(DenseMatrix&lt; double &gt; *, bool sensitivity_calculation=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_plate_d_k_q.html#a108bacf150462c96211d1f1f1af7efcb">PlateDKQ::calculate_M</a> </td>
          <td>(</td>
          <td class="paramtype">DenseMatrix&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sensitivity_calculation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_plate_d_k_q_8_c_source.html#l00038">38</a> of file <a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a>.</p>
<div class="fragment"><pre class="fragment">{
  abort();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86758dc3b8b18443e1bb814a09449328"></a><!-- doxytag: member="PlateDKQ::calculateShearStiffnessFactor" ref="a86758dc3b8b18443e1bb814a09449328" args="(DenseMatrix&lt; double &gt; *matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_plate_d_k_q.html#a86758dc3b8b18443e1bb814a09449328">PlateDKQ::calculateShearStiffnessFactor</a> </td>
          <td>(</td>
          <td class="paramtype">DenseMatrix&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_plate_d_k_q_8_c_source.html#l00198">198</a> of file <a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// initialize the element if it is not already initialized</span>
  <span class="keywordflow">if</span> (this-&gt;local_elem_is_initialized == <span class="keyword">false</span>)
    this-&gt;initialize_element();

<span class="comment">//   unsigned int num_nodes = this-&gt;base_elem-&gt;n_nodes();</span>

<span class="comment">//   DenseMatrix&lt;double&gt; Nx_Nx(num_nodes,num_nodes),</span>
<span class="comment">//     Ny_Ny(num_nodes,num_nodes),</span>
<span class="comment">//     Nx_N(num_nodes,num_nodes), Ny_N(num_nodes,num_nodes),</span>
<span class="comment">//     N_N(num_nodes,num_nodes);</span>

<span class="comment">//   this-&gt;getFactor(&amp;Nx_Nx, StructuralElem::N_X_N_X_FACTOR);</span>
<span class="comment">//   this-&gt;getFactor(&amp;Ny_Ny, StructuralElem::N_Y_N_Y_FACTOR);</span>
<span class="comment">//   this-&gt;getFactor(&amp;Nx_N, StructuralElem::N_X_N_FACTOR);</span>
<span class="comment">//   this-&gt;getFactor(&amp;Ny_N, StructuralElem::N_Y_N_FACTOR);</span>
<span class="comment">//   this-&gt;getFactor(&amp;N_N, StructuralElem::N_N_FACTOR);</span>
  

<span class="comment">//   for (unsigned int i=0; i&lt;num_nodes; i++)</span>
<span class="comment">//     for (unsigned int j=0; j&lt;num_nodes; j++)</span>
<span class="comment">//       {</span>
<span class="comment">//      (*matrix)(2*num_nodes+i,2*num_nodes+j) += (Nx_Nx(i,j) + Ny_Ny(i,j));</span>
<span class="comment">//      (*matrix)(2*num_nodes+i,3*num_nodes+j) += -Ny_N(i,j);</span>
<span class="comment">//      (*matrix)(2*num_nodes+i,4*num_nodes+j) += Nx_N(i,j);</span>


<span class="comment">//      (*matrix)(3*num_nodes+i,2*num_nodes+j) += -Ny_N(j,i);</span>
<span class="comment">//      (*matrix)(4*num_nodes+i,2*num_nodes+j) += Nx_N(j,i);</span>
        
<span class="comment">//      (*matrix)(3*num_nodes+i,3*num_nodes+j) += N_N(i,j);</span>
<span class="comment">//      (*matrix)(4*num_nodes+i,4*num_nodes+j) += N_N(i,j);</span>
<span class="comment">//       }</span>
  

<span class="comment">//   return;</span>
        
  <span class="keywordtype">double</span> x12, x43, x14, x23, y12, y43, y14, y23; <span class="comment">// data for tensorial shear strain integration</span>
  <span class="keywordtype">double</span> Ax, Bx, Cx, Ay, By, Cy, sin_alpha, cos_alpha, sin_beta, cos_beta;
        
  <span class="comment">// from the local element, get the nodes</span>
  <span class="comment">// the computaion of the shear factor requires an element </span>
  <span class="comment">// where the (x,y) = (0,0) is at node 2, and </span>
  <span class="comment">// (xi, eta) = (1,1) is at node 0. For the calculation in </span>
  <span class="comment">// FESystemElement, these points are node 0 and 2 respectively. </span>
  <span class="comment">// Also, for this shear factor, required x-axis is from node 2 to node 3,</span>
  <span class="comment">// and for the local axis, it is from node 0 to node 1. Hence, </span>
  <span class="comment">// if we simply renumber the nodes as </span>
  <span class="comment">// local elem        bathe&#39;s elem</span>
  <span class="comment">//    0                   2    </span>
  <span class="comment">//    1                   3</span>
  <span class="comment">//    2                   0 </span>
  <span class="comment">//    3                   1</span>
  <span class="comment">// we can use the same axis system for calculation.</span>

  <span class="keyword">const</span> Point&amp; new_point0 = this-&gt;_local_elem-&gt;point(2);
  <span class="keyword">const</span> Point&amp; new_point1 = this-&gt;_local_elem-&gt;point(3);
  <span class="keyword">const</span> Point&amp; new_point2 = this-&gt;_local_elem-&gt;point(0);
  <span class="keyword">const</span> Point&amp; new_point3 = this-&gt;_local_elem-&gt;point(1);
  
  <span class="comment">// calculate data for tensorial strain inegration</span>
  x12 = new_point0(0) - new_point1(0);
  x14 = new_point0(0) - new_point3(0);
  x23 = new_point1(0) - new_point2(0);
  x43 = new_point3(0) - new_point2(0);
        
  y12 = new_point0(1) - new_point1(1);
  y14 = new_point0(1) - new_point3(1);
  y23 = new_point1(1) - new_point2(1);
  y43 = new_point3(1) - new_point2(1);
        
  Ax = new_point0(0) - new_point1(0) - new_point2(0) + new_point3(0);
  Bx = new_point0(0) - new_point1(0) + new_point2(0) - new_point3(0);
  Cx = new_point0(0) + new_point1(0) - new_point2(0) - new_point3(0); 
        
  Ay = new_point0(1) - new_point1(1) - new_point2(1) + new_point3(1); 
  By = new_point0(1) - new_point1(1) + new_point2(1) - new_point3(1); 
  Cy = new_point0(1) + new_point1(1) - new_point2(1) - new_point3(1);
        
<span class="comment">//   // calculate the locations of A,B,C,D, and use that to calculate the </span>
<span class="comment">//   // cosine and sine for the angles alpha and beta. </span>
<span class="comment">//   // alpha is the angle betweem r and x</span>
<span class="comment">//   // beta is the angle between s and x</span>
<span class="comment">//   Point A_loc, B_loc, C_loc, D_loc, CA_vec, BD_vec, x_vec;</span>
        
<span class="comment">//   A_loc.assign(new_point0+new_point1); A_loc*0.5;</span>
<span class="comment">//   B_loc.assign(new_point1+new_point2); B_loc*0.5;</span>
<span class="comment">//   C_loc.assign(new_point2+new_point3); C_loc*0.5;</span>
<span class="comment">//   D_loc.assign(new_point3+new_point0); D_loc*0.5;</span>
  
<span class="comment">//   x_vec.assign(new_point3-new_point2); </span>
<span class="comment">//   CA_vec.assign(A_loc - C_loc);</span>
<span class="comment">//   BD_vec.assign(D_loc - B_loc);</span>
        
<span class="comment">//   cos_beta = (x_vec * CA_vec)/ (x_vec.size() * CA_vec.size());</span>
<span class="comment">//   cos_alpha = (x_vec * BD_vec)/ (x_vec.size() * BD_vec.size());</span>
<span class="comment">//   // following has been done to avoind getting NANs in the code. </span>
<span class="comment">//   // the problem is that cos_alpha or cos_beta, sometimes ends up being</span>
<span class="comment">//   // equal to 1, and 1.0 - cos^2 gives a very small negative number, which </span>
<span class="comment">//   // is practically zero. Hence, if this happend, they will be practically </span>
<span class="comment">//   // set to zero.</span>
<span class="comment">//   // in both cases, if the test does not pass, the code will abort, sicne the </span>
<span class="comment">//   // cos of an angle cannot be &gt; 1.</span>
<span class="comment">//   double sin_alpha_square = 1.0 - cos_alpha*cos_alpha,</span>
<span class="comment">//     sin_beta_square = 1.0 - cos_beta*cos_beta;</span>

<span class="comment">//   if (sin_alpha_square &lt; 0.0)</span>
<span class="comment">//     {</span>
<span class="comment">//       if (fabs(sin_alpha_square) &lt; 1.0e-12)</span>
<span class="comment">//      sin_alpha_square = 0.0;</span>
<span class="comment">//       else</span>
<span class="comment">//      abort();</span>
<span class="comment">//     }</span>

<span class="comment">//   if (sin_beta_square &lt; 0.0)</span>
<span class="comment">//     {</span>
<span class="comment">//       if (fabs(sin_beta_square) &lt; 1.0e-12)</span>
<span class="comment">//      sin_beta_square = 0.0;</span>
<span class="comment">//       else</span>
<span class="comment">//      abort();</span>
<span class="comment">//     }</span>

<span class="comment">//   sin_alpha = sqrt(sin_alpha_square);</span>
<span class="comment">//   sin_beta = sqrt(sin_beta_square);</span>

  
        
  std::vector&lt;Real&gt;&amp; JxW = *(this-&gt;_JxW);
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_nodes = this-&gt;base_elem-&gt;n_nodes();

  DenseVector&lt;double&gt; gamma_rz(12), gamma_sz(12), gamma_xz(12), gamma_yz(12);
  <span class="keywordtype">double</span> xi, eta, ABx_factor, ABy_factor, CBx_factor, CBy_factor, det_J;
  matrix-&gt;zero();

  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qp=0; qp&lt;this-&gt;_qbase_2d-&gt;n_points(); qp++)
    {
      gamma_rz.zero(); gamma_sz.zero(); gamma_xz.zero(); gamma_yz.zero();
      
      xi = (this-&gt;_qbase_2d-&gt;get_points())[qp](0);
      eta = (this-&gt;_qbase_2d-&gt;get_points())[qp](1);
      <span class="comment">//            det_J = (JxW[qp])/((this-&gt;_qbase_2d-&gt;get_weights())[qp]);</span>
      det_J = (1.0 / 16.0) * ((Cy + xi * By)*(Ax + eta * Bx) - 
                              (Cx + xi * Bx)*(Ay + eta * By) );

      <span class="comment">// numerators of the dot product of </span>
      ABy_factor = (Ay + eta * By) / 16.0 / det_J;
      ABx_factor = (Ax + eta * Bx) / 16.0 / det_J;
      CBy_factor = (Cy + xi * By) / 16.0 / det_J;
      CBx_factor = (Cx + xi * Bx) / 16.0 / det_J;

      gamma_rz(0) =  (1+eta);
      gamma_rz(1) = -(1+eta);
      gamma_rz(2) = -(1-eta);
      gamma_rz(3) =  (1-eta);
                
      gamma_rz(4) = -.5 * (1+eta) * y12;
      gamma_rz(5) = -.5 * (1+eta) * y12;
      gamma_rz(6) = -.5 * (1-eta) * y43;
      gamma_rz(7) = -.5 * (1-eta) * y43;
                
      gamma_rz(8) =  .5 * (1+eta) * x12;
      gamma_rz(9) =  .5 * (1+eta) * x12;
      gamma_rz(10) = .5 * (1-eta) * x43;
      gamma_rz(11) = .5 * (1-eta) * x43;
                
      gamma_sz(0) =  (1+xi);
      gamma_sz(1) =  (1-xi);
      gamma_sz(2) = -(1-xi);
      gamma_sz(3) = -(1+xi);
                
      gamma_sz(4) = -.5 * (1+xi) * y14;
      gamma_sz(5) = -.5 * (1-xi) * y23;
      gamma_sz(6) = -.5 * (1-xi) * y23;
      gamma_sz(7) = -.5 * (1+xi) * y14;
                
      gamma_sz(8) =  .5 * (1+xi) * x14;
      gamma_sz(9) =  .5 * (1-xi) * x23;
      gamma_sz(10) = .5 * (1-xi) * x23;
      gamma_sz(11) = .5 * (1+xi) * x14;
      
      <span class="comment">// now initialize the values of gamma_xz, and gamma_yz</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; 12; i++)
        {
          gamma_xz(i) = gamma_rz(i) * CBy_factor - gamma_sz(i) * ABy_factor;
          gamma_yz(i) = -gamma_rz(i) * CBx_factor + gamma_sz(i) * ABx_factor;
        }

<span class="comment">//       gamma_rz.scale(1.0/16.0);</span>
<span class="comment">//       gamma_sz.scale(1.0/16.0);</span>

<span class="comment">//       std::cout &lt;&lt; &quot;Quad point: xi-&gt; &quot; &lt;&lt; xi &lt;&lt; &quot;  eta-&gt; &quot; &lt;&lt; eta &lt;&lt; std::endl;</span>
<span class="comment">//       std::cout &lt;&lt; &quot; Det J = &quot; &lt;&lt; det_J &lt;&lt; std::endl; </span>
<span class="comment">//       std::cout &lt;&lt; &quot; gamma_r_z : \n&quot; &lt;&lt; gamma_rz &lt;&lt; std::endl;</span>
<span class="comment">//       std::cout &lt;&lt; &quot; gamma_s_z : \n&quot; &lt;&lt; gamma_sz &lt;&lt; std::endl;</span>
<span class="comment">//       std::cout &lt;&lt; &quot; gamma_x_z : \n&quot; &lt;&lt; gamma_xz &lt;&lt; std::endl;</span>
<span class="comment">//       std::cout &lt;&lt; &quot; gamma_y_z : \n&quot; &lt;&lt; gamma_yz &lt;&lt; std::endl;</span>

<span class="comment">//       std::cout &lt;&lt; &quot;sin beta : &quot; &lt;&lt; sin_beta &lt;&lt; &quot;  &quot; </span>
<span class="comment">//              &lt;&lt; (CBy_factor/ sqrt(pow(CBy_factor,2) + pow(CBx_factor,2))) </span>
<span class="comment">//              &lt;&lt; std::endl;</span>
<span class="comment">//       std::cout &lt;&lt; &quot;sin alpha : &quot; &lt;&lt; sin_alpha &lt;&lt; &quot;  &quot; </span>
<span class="comment">//              &lt;&lt; (ABy_factor/ sqrt(pow(ABy_factor,2) + pow(ABx_factor,2))) </span>
<span class="comment">//              &lt;&lt; std::endl;</span>
<span class="comment">//       std::cout &lt;&lt; &quot;cos beta : &quot; &lt;&lt; cos_beta &lt;&lt; &quot;  &quot; </span>
<span class="comment">//              &lt;&lt; (CBx_factor/ sqrt(pow(CBy_factor,2) + pow(CBx_factor,2))) </span>
<span class="comment">//              &lt;&lt; std::endl;</span>
<span class="comment">//       std::cout &lt;&lt; &quot;cos_alpha : &quot; &lt;&lt; cos_alpha &lt;&lt; &quot;  &quot; </span>
<span class="comment">//              &lt;&lt; (ABx_factor/ sqrt(pow(ABy_factor,2) + pow(ABx_factor,2))) </span>
<span class="comment">//              &lt;&lt; std::endl;</span>
                
      <span class="comment">// Now add the shear contribution to the stiffness matrix.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;4; i++)
        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;4; j++)
          {
            (*matrix)(2*n_nodes+i,2*n_nodes+j) += (JxW[qp])*(gamma_xz(i)*gamma_xz(j) +
                                                             gamma_yz(i)*gamma_yz(j));
            (*matrix)(2*n_nodes+i,3*n_nodes+j) += (JxW[qp])*(gamma_xz(i)*gamma_xz(n_nodes+j) + 
                                                             gamma_yz(i)*gamma_yz(n_nodes+j));
            (*matrix)(2*n_nodes+i,4*n_nodes+j) += (JxW[qp])*(gamma_xz(i)*gamma_xz(2*n_nodes+j) + 
                                                             gamma_yz(i)*gamma_yz(2*n_nodes+j));
                                
            (*matrix)(3*n_nodes+i,2*n_nodes+j) += (JxW[qp])*(gamma_xz(n_nodes+i)*gamma_xz(j) + 
                                                             gamma_yz(n_nodes+i)*gamma_yz(j));
            (*matrix)(3*n_nodes+i,3*n_nodes+j) += (JxW[qp])*(gamma_xz(n_nodes+i)*gamma_xz(n_nodes+j) + 
                                                             gamma_yz(n_nodes+i)*gamma_yz(n_nodes+j));
            (*matrix)(3*n_nodes+i,4*n_nodes+j) += (JxW[qp])*(gamma_xz(n_nodes+i)*gamma_xz(2*n_nodes+j) + 
                                                             gamma_yz(n_nodes+i)*gamma_yz(2*n_nodes+j));
                                
            (*matrix)(4*n_nodes+i,2*n_nodes+j) += (JxW[qp])*(gamma_xz(2*n_nodes+i)*gamma_xz(j) + 
                                                             gamma_yz(2*n_nodes+i)*gamma_yz(j));
            (*matrix)(4*n_nodes+i,3*n_nodes+j) += (JxW[qp])*(gamma_xz(2*n_nodes+i)*gamma_xz(n_nodes+j) + 
                                                             gamma_yz(2*n_nodes+i)*gamma_yz(n_nodes+j));
            (*matrix)(4*n_nodes+i,4*n_nodes+j) += (JxW[qp])*(gamma_xz(2*n_nodes+i)*gamma_xz(2*n_nodes+j) + 
                                                             gamma_yz(2*n_nodes+i)*gamma_yz(2*n_nodes+j));
          }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0bf3e67479bf5a7d06ddd4c6afd4028f"></a><!-- doxytag: member="PlateDKQ::getElementPostProcessQty" ref="a0bf3e67479bf5a7d06ddd4c6afd4028f" args="(std::vector&lt; unsigned int &gt;, std::vector&lt; DesignData::DesignParameter * &gt;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt; <a class="el" href="class_elem_post_process_qty.html">ElemPostProcessQty</a> &gt; <a class="el" href="class_plate_d_k_q.html#a0bf3e67479bf5a7d06ddd4c6afd4028f">PlateDKQ::getElementPostProcessQty</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>load_cases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_design_data_1_1_design_parameter.html">DesignData::DesignParameter</a> * &gt;&#160;</td>
          <td class="paramname"><em>dv_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this function returns a vector of the post process quanties for this element. The quantities will consist of the strain, stress and their sensitivities. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>of load case IDs for which the post process quantities need to be calculated </td></tr>
    <tr><td class="paramname">vector</td><td>of DVs for which the quantities need to be calculated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_plate_d_k_q_8_c_source.html#l00631">631</a> of file <a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::auto_ptr&lt;ElemPostProcessQty&gt; return_qty(<span class="keyword">new</span> <a class="code" href="class_elem_post_process_qty.html">ElemPostProcessQty</a>(this-&gt;_elem_ID));

  TensorValue&lt;double&gt; tensor;

  <span class="comment">// create an fe that will be used for calculationi of the element strains and</span>
  <span class="comment">// stresses. The vector fe_sens is for shape sensitivity</span>
  std::auto_ptr&lt;FEBase&gt; fe(<span class="keyword">new</span> FE&lt;2,LAGRANGE&gt;(FEType())),
    fe_sens (<span class="keyword">new</span> FE&lt;2,LAGRANGE&gt;(FEType()));

  <span class="keywordtype">double</span> temp_strain_material_factor = 0.0, temp_strain_material_factor_sens = 0.0,
    ref_temp = 0.0, E_11 =0.0, nu = 0.0, thickness = 0.0;
 

  <span class="comment">// initialize the material factors</span>
  PropertyCard&amp; property_card = *(this-&gt;_elem_property_card);
  temp_strain_material_factor = property_card[Property::ALPHA_EXPANSION];
  ref_temp = property_card[Property::TEMP_REF];
  E_11 = property_card[Property::E_11];
  nu = property_card[Property::NU];
  thickness = property_card[Property::THICKNESS];


  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_nodes = this-&gt;base_elem-&gt;n_nodes();

  DenseMatrix&lt;double&gt; B_strain(3, 6*n_nodes) , B_strain_sens(3, 6*n_nodes);

  <span class="comment">// create rest of the necessary data structures</span>
  DenseVector&lt;double&gt;  strain(3), strain_sens(3),
    stress(3), stress_sens(3), strain_plus_thermal(3), 
    strain_plus_thermal_sens(3), strain_scratch(3);
  
  DenseMatrix&lt;double&gt; material_factor(3,3), material_factor_sens(3,3);


  
  <span class="comment">// point at which this element will be initialized</span>
  <span class="comment">// for now, this is only the centroid of the element</span>
  std::vector&lt;Point&gt; point_vec;
  point_vec.push_back(Point(0.0,0.0,0.0));

  <span class="comment">// then, reinit it at the base elem, at the element centroid, where the </span>
  <span class="comment">// element strains and stresses will be evaluated</span>
  fe-&gt;reinit(this-&gt;base_elem, &amp;point_vec);

  <span class="comment">// get the necessary data out of this element </span>
  <span class="keyword">const</span> std::vector&lt; std::vector&lt;Real&gt; &gt;&amp; dphi_dx = fe-&gt;get_dphidx();
  <span class="keyword">const</span> std::vector&lt; std::vector&lt;Real&gt; &gt;&amp; dphi_dy = fe-&gt;get_dphidy();
  <span class="keyword">const</span> std::vector&lt;std::vector&lt;Real&gt; &gt;&amp; phi = fe-&gt;get_phi();

  <span class="comment">// calculate B_strain matrix. Since the calculation is being performed at a single point, </span>
  <span class="comment">// the vector of shape factor derivatives should have size = 1</span>
  assert (dphi_dx[0].size() == 1);
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; n_nodes; i++)
    {
      B_strain(0,i) = dphi_dx[i][0];  <span class="comment">// epsilon_xx</span>
      B_strain(0,4*n_nodes+i) = 0.5 * thickness * dphi_dx[i][0]; <span class="comment">// bending contribution</span>
      B_strain(1,n_nodes+i) = dphi_dy[i][0];  <span class="comment">// epsilon_yy</span>
      B_strain(1,3*n_nodes+i) = - 0.5 * thickness * dphi_dy[i][0]; <span class="comment">// bending contribution</span>
      B_strain(2,i) = dphi_dy[i][0];  <span class="comment">// epsilon  xy </span>
      B_strain(2,3*n_nodes+i) = - 0.5 * thickness * dphi_dx[i][0]; <span class="comment">// bending contribution</span>
      B_strain(2,n_nodes+i) = dphi_dx[i][0];  <span class="comment">// epsilon xy</span>
      B_strain(2,4*n_nodes+i) = 0.5 * thickness * dphi_dy[i][0]; <span class="comment">// bending contribution</span>
    }
  

  <span class="comment">// iterate over all the load cases, to calculate the strains and stresses</span>
  std::vector&lt;unsigned int&gt;::const_iterator load_case_it = load_cases.begin();
  std::vector&lt;unsigned int&gt;::const_iterator load_case_end = load_cases.end();   
        
  std::vector&lt;DesignData::DesignParameter*&gt;::const_iterator dv_it, dv_begin, dv_end;
  dv_begin = dv_vector.begin();
  dv_end = dv_vector.end();
        
  
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> property_card_ID = 0;
  Property::PropertyName prpty_name;

  std::auto_ptr&lt;DenseMatrix&lt;double&gt; &gt; transform_mat(<span class="keyword">new</span> DenseMatrix&lt;double&gt;), 
    transform_mat_sens(<span class="keyword">new</span> DenseMatrix&lt;double&gt;);
  this-&gt;resizeQty(transform_mat.get());
  this-&gt;resizeQty(transform_mat_sens.get());

  this-&gt;getFactor(transform_mat.get(), StructuralElem::TRANSFORM_MATRIX);


  <span class="comment">// also, create dof_vectors</span>
  DenseVector&lt;double&gt;  dof_values(6*n_nodes), dof_value_sens(6*n_nodes),
    local_dof(6*n_nodes), local_dof_sens(6*n_nodes), scratch_vec(6*n_nodes),
    nodal_temp(n_nodes),nodal_temp_sens(n_nodes),
    dphi_dx_sens(n_nodes), dphi_dy_sens(n_nodes);
  

  <span class="comment">// set the material factor matrix</span>
  material_factor(0,0) = E_11 / (1.0 - nu * nu);
  material_factor(0,1) = E_11 * nu / (1.0 - nu * nu);
  material_factor(1,0) = E_11 * nu / (1.0 - nu * nu);
  material_factor(1,1) = E_11 / (1.0 - nu * nu);
  material_factor(2,2) = E_11 * 0.5 / (1.0 + nu);
  
  <span class="keywordtype">double</span> temp = 0.0, temp_sens = 0.0;

  <span class="comment">// iterate over each load case, and ask solver to solve for it</span>
  <span class="keywordflow">for</span> (; load_case_it != load_case_end; load_case_it++)
    {
      
      <span class="comment">// get the DOF vector for this elem</span>
      dof_values = *(this-&gt;getElemDofValuesForLoadCase(*load_case_it).get());

      <span class="comment">// transform these dofs to the local coordinate system</span>
      local_dof.zero();
      transform_mat-&gt;right_multiply_vector(dof_values, local_dof);

      <span class="comment">// get the loads for this element</span>
      this-&gt;getNodalTemperatureVector(nodal_temp, *load_case_it);

      <span class="comment">// calculate the factor and the strain and stress</span>
      B_strain.right_multiply_vector(local_dof, strain);

      <span class="comment">// add the thermal strain component and then calculate the stress</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;phi.size(); i++)
        temp += phi[i][0] * nodal_temp(i);

      strain_plus_thermal.zero();
      strain_plus_thermal(0) = strain(0) - temp_strain_material_factor * (temp - ref_temp);
      strain_plus_thermal(1) = strain(1) - temp_strain_material_factor * (temp - ref_temp);
      strain_plus_thermal(2) = strain(2);

      <span class="comment">// now multiply to calculate the stresses</span>
      material_factor.right_multiply_vector(strain_plus_thermal, stress);


      <span class="comment">// add the two tensors</span>
      tensor.zero();
      tensor(0,0) = strain(0);  <span class="comment">// xx</span>
      tensor(1,1) = strain(1);  <span class="comment">// yy</span>
      tensor(0,1) = strain(2);  <span class="comment">// xy</span>
      tensor(1,0) = strain(2);  <span class="comment">// yx</span>
      return_qty-&gt;addStrainTensor(tensor, *load_case_it);
      
      tensor.zero();
      tensor(0,0) = stress(0);  <span class="comment">// xx</span>
      tensor(1,1) = stress(1);  <span class="comment">// yy</span>
      tensor(0,1) = stress(2);  <span class="comment">// xy</span>
      tensor(1,0) = stress(2);  <span class="comment">// yx</span>
      return_qty-&gt;addStressTensor(tensor, *load_case_it);

      tensor.zero();
      tensor(0,0) = strain_plus_thermal(0);  <span class="comment">// xx</span>
      tensor(1,1) = strain_plus_thermal(1);  <span class="comment">// yy</span>
      tensor(0,1) = strain_plus_thermal(2);  <span class="comment">// xy</span>
      tensor(1,0) = strain_plus_thermal(2);  <span class="comment">// yx</span>
      return_qty-&gt;addMechanicalStrainTensor(tensor, *load_case_it);

      <span class="comment">// now calculate the sensitivities</span>
      dv_it = dv_begin;
      <span class="keywordflow">for</span> (; dv_it != dv_end; dv_it++)
        {
          <span class="comment">// get the dof value sensitivity for this case</span>
          dof_value_sens = *(this-&gt;getElemDofValueSensitivityForLoadCaseAndDV(*load_case_it, (*dv_it)-&gt;ID()).<span class="keyword">get</span>());
          
          <span class="comment">// get the load sensitivity vectors</span>
          this-&gt;getNodalTemperatureVector(nodal_temp_sens, *load_case_it, <span class="keyword">true</span>, (*dv_it)-&gt;ID());

          material_factor_sens.zero();
          temp_strain_material_factor_sens = 0.0;
          
          <span class="comment">// set the DV for this element </span>
          this-&gt;DV = *dv_it;

          <span class="keywordflow">switch</span> ((*dv_it)-&gt;type())
            {
            <span class="keywordflow">case</span> PROPERTY_DV:
              {
                <span class="comment">// for a property DV, the strain operator sensitivity will be zero</span>
                B_strain_sens.zero();

                PropertyDesignVariable* prpty_DV = <span class="keyword">dynamic_cast&lt;</span>PropertyDesignVariable*<span class="keyword">&gt;</span>(*dv_it);

                <span class="comment">// get the property ID and name</span>
                property_card_ID = prpty_DV-&gt;propertyCardID();
                prpty_name = prpty_DV-&gt;propertyName();
                
                <span class="comment">// if the property ID is the same as this elements property, then set the </span>
                <span class="comment">// value of the property sensitivity. Else the value be zero</span>
                <span class="keywordflow">if</span> ( property_card_ID == this-&gt;_elem_property_card-&gt;id())
                  {
                    <span class="keywordflow">switch</span> (prpty_name)
                      {
                      <span class="keywordflow">case</span> Property::E_11:
                        {
                          material_factor_sens(0,0) = 1.0 / (1.0- nu * nu);
                          material_factor_sens(0,1) = nu / (1.0- nu * nu);
                          material_factor_sens(1,0) =  nu / (1.0- nu * nu);
                          material_factor_sens(1,1) = 1.0 / (1.0- nu * nu);
                          material_factor_sens(2,2) =  0.5 / (1 + nu);

                          temp_strain_material_factor_sens = 0.0;
                        }
                        <span class="keywordflow">break</span>;
                                                                

                      <span class="keywordflow">case</span> Property::NU:
                        {
                          material_factor_sens(0,0) = 2.0 * nu * E_11 / pow((1.0- nu * nu),2);
                          material_factor_sens(0,1) = E_11 * (1.0+ nu*nu) / pow((1.0 - nu * nu),2);
                          material_factor_sens(1,0) = E_11 * (1.0+ nu*nu) / pow((1.0 - nu * nu),2);
                          material_factor_sens(1,1) = 2.0 * nu * E_11 / pow((1.0- nu * nu),2);
                          material_factor_sens(2,2) = - E_11 * 0.5 / pow((1 + nu),2);

                          temp_strain_material_factor_sens = 0.0;
                        }
                        <span class="keywordflow">break</span>;


                      <span class="keywordflow">case</span> Property::ALPHA_EXPANSION:
                        {
                          material_factor_sens.zero();

                          temp_strain_material_factor_sens = 1.0;
                        }
                        <span class="keywordflow">break</span>;

                      <span class="keywordflow">case</span> Property::THICKNESS:
                        {
                          material_factor_sens.zero();

                          temp_strain_material_factor_sens = 0.0;
                          
                          <span class="comment">// set the value of the </span>
                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; n_nodes; i++)
                            {
                              B_strain_sens(0,4*n_nodes+i) = 0.5 * dphi_dx[i][0]; <span class="comment">// bending contribution</span>
                              B_strain_sens(1,3*n_nodes+i) = - 0.5 * dphi_dy[i][0]; <span class="comment">// bending contribution</span>
                              B_strain_sens(2,3*n_nodes+i) = -0.5 * dphi_dx[i][0]; <span class="comment">// bending contribution</span>
                              B_strain_sens(2,4*n_nodes+i) = 0.5 * dphi_dy[i][0]; <span class="comment">// bending contribution</span>
                            }

                        }
                        <span class="keywordflow">break</span>;


                      <span class="keywordflow">default</span>:
                        {
                          material_factor_sens.zero();

                          temp_strain_material_factor_sens = 0.0;
                        }
                        <span class="keywordflow">break</span>;
                      }
                  }
                <span class="keywordflow">else</span> 
                  {
                    material_factor_sens.zero();

                    temp_strain_material_factor_sens = 0.0;
                  }

                <span class="comment">// also, calculate the sensitivity of the dof vector. The transformation matrix sensitivity </span>
                <span class="comment">// will be zero for this case, since shape sensitivity will be zero</span>
                transform_mat-&gt;right_multiply_vector(dof_value_sens, local_dof_sens);
              }
              <span class="keywordflow">break</span>;
                                
            <span class="keywordflow">case</span> SHAPE_DV:
              {
                <span class="comment">// calculate the length for the perturbed element, and find the sensitivity</span>
                <span class="comment">// calculate the length of the element</span>
                <span class="comment">// first init the perturbed elem</span>
                this-&gt;initPerturbedElemForShapeDV();

                <span class="comment">// set the factor_sens to zero</span>
                material_factor_sens.zero();

                temp_strain_material_factor_sens = 0.0;

                <span class="comment">// get the transformation matrix sensitivity and calculate the local_dof_sens</span>
                this-&gt;getFactorShapeSensitivity(transform_mat_sens.get(), StructuralElem::TRANSFORM_MATRIX);
                
                local_dof_sens.zero(); scratch_vec.zero();
                transform_mat_sens-&gt;right_multiply_vector(dof_values, local_dof_sens);
                
                scratch_vec.zero();
                transform_mat-&gt;right_multiply_vector(dof_value_sens, scratch_vec);
                
                local_dof_sens.add(1.0, scratch_vec);

                
                ShapeDesignVariable* shape_DV = <span class="keyword">dynamic_cast&lt;</span>ShapeDesignVariable*<span class="keyword">&gt;</span>(this-&gt;DV);
                <span class="keywordtype">double</span> perturbation = shape_DV-&gt;perturbation();
                                        
                <span class="comment">// now init the fe_sens to the perturbed DV and calculate the shape sensitivity of the</span>
                <span class="comment">// B matrix</span>
                <span class="comment">// then, reinit it at the base elem, at the element centroid, where the </span>
                <span class="comment">// element strains and stresses will be evaluated</span>
                fe_sens-&gt;reinit(this-&gt;perturbed_elem, &amp;point_vec);

                <span class="comment">// get the necessary data out of this element </span>
                <span class="keyword">const</span> std::vector&lt; std::vector&lt;Real&gt; &gt;&amp; dphi_dx_perturbed = fe_sens-&gt;get_dphidx();
                <span class="keyword">const</span> std::vector&lt; std::vector&lt;Real&gt; &gt;&amp; dphi_dy_perturbed = fe_sens-&gt;get_dphidy();
                
                dphi_dx_sens.zero();
                dphi_dy_sens.zero();
                
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_nodes; i++)
                  {
                    dphi_dx_sens(i) = dphi_dx_perturbed[i][0] - dphi_dx[i][0];
                    dphi_dy_sens(i) = dphi_dy_perturbed[i][0] - dphi_dy[i][0];
                  }

                dphi_dx_sens.scale(1.0/perturbation);
                dphi_dy_sens.scale(1.0/perturbation);

                <span class="comment">// calculate B_strain matrix. Since the calculation is being performed at a single point, </span>
                <span class="comment">// the vector of shape factor derivatives should have size = 1</span>

                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; n_nodes; i++)
                  {
                    B_strain_sens(0,i) = dphi_dx_sens(i);  <span class="comment">// epsilon_xx</span>
                    B_strain_sens(0,4*n_nodes+i) = 0.5 * thickness * dphi_dx_sens(i); <span class="comment">// bending contribution</span>
                    B_strain_sens(1,n_nodes+i) = dphi_dy_sens(i);  <span class="comment">// epsilon_yy</span>
                    B_strain_sens(1,3*n_nodes+i) = - 0.5 * thickness * dphi_dy_sens(i); <span class="comment">// bending contribution</span>
                    B_strain_sens(2,i) = dphi_dy_sens(i);  <span class="comment">// epsilon  xy </span>
                    B_strain_sens(2,3*n_nodes+i) = -0.5 * thickness * dphi_dx_sens(i); <span class="comment">// bending contribution</span>
                    B_strain_sens(2,n_nodes+i) = dphi_dx_sens(i);  <span class="comment">// epsilon xy</span>
                    B_strain_sens(2,4*n_nodes+i) = 0.5 * thickness * dphi_dy_sens(i); <span class="comment">// bending contribution</span>
                  }
                
              }
              <span class="keywordflow">break</span>;
              
            <span class="keywordflow">default</span>:
              abort();
              <span class="keywordflow">break</span>;
            }
          
          <span class="comment">// calculate the strain and stress</span>
          <span class="comment">// calculate the factor and the strain and stress</span>
          strain_scratch.zero();
          B_strain.right_multiply_vector(local_dof_sens, strain_sens);
          B_strain_sens.right_multiply_vector(local_dof, strain_scratch);
          strain_sens.add(1.0, strain_scratch);

          <span class="comment">// add the thermal strain component and then calculate the stress</span>
          temp_sens = 0.0;
          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;phi.size(); i++)
            temp_sens += phi[i][0] * nodal_temp_sens(i);
          
          <span class="comment">// add the temperture sensitivity effects to the strain sensitivity</span>
          strain_plus_thermal_sens.zero();
          strain_plus_thermal_sens(0) = strain_sens(0) - temp_strain_material_factor * temp_sens -
            temp_strain_material_factor_sens * (temp - ref_temp);
          strain_plus_thermal_sens(1) = strain_sens(1) - temp_strain_material_factor * temp_sens -
            temp_strain_material_factor_sens * (temp - ref_temp);
          strain_plus_thermal_sens(2) = strain_sens(2);

          <span class="comment">// now multiply to calculate the stresses</span>
          strain_scratch.zero();
          material_factor_sens.right_multiply_vector(strain_plus_thermal, stress_sens);
          material_factor.right_multiply_vector(strain_plus_thermal_sens, strain_scratch);
          stress_sens.add(1.0, strain_scratch);

          <span class="comment">// add the two tensors</span>
          tensor.zero();
          tensor(0,0) = strain_sens(0);  <span class="comment">// xx</span>
          tensor(1,1) = strain_sens(1);  <span class="comment">// yy</span>
          tensor(0,1) = strain_sens(2);  <span class="comment">// xy</span>
          tensor(1,0) = strain_sens(2);  <span class="comment">// yx</span>
          return_qty-&gt;addStrainTensor(tensor, *load_case_it,  (*dv_it)-&gt;ID());
      
          tensor.zero();
          tensor(0,0) = stress_sens(0);  <span class="comment">// xx</span>
          tensor(1,1) = stress_sens(1);  <span class="comment">// yy</span>
          tensor(0,1) = stress_sens(2);  <span class="comment">// xy</span>
          tensor(1,0) = stress_sens(2);  <span class="comment">// yx</span>
          return_qty-&gt;addStressTensor(tensor, *load_case_it, (*dv_it)-&gt;ID());

          tensor.zero();
          tensor(0,0) = strain_plus_thermal_sens(0);  <span class="comment">// xx</span>
          tensor(1,1) = strain_plus_thermal_sens(1);  <span class="comment">// yy</span>
          tensor(0,1) = strain_plus_thermal_sens(2);  <span class="comment">// xy</span>
          tensor(1,0) = strain_plus_thermal_sens(2);  <span class="comment">// yx</span>
          return_qty-&gt;addMechanicalStrainTensor(tensor, *load_case_it,  (*dv_it)-&gt;ID());

        }
    }  

  <span class="keywordflow">return</span> return_qty;
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/manav/Documents/codes/FESystemOld/FESystem/src/StructuralElems/<a class="el" href="_plate_d_k_q_8h_source.html">PlateDKQ.h</a></li>
<li>/Users/manav/Documents/codes/FESystemOld/FESystem/src/StructuralElems/<a class="el" href="_plate_d_k_q_8_c_source.html">PlateDKQ.C</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 12 2012 18:06:20 for fesystem by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
