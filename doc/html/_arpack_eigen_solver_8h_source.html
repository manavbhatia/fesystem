<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>fesystem: /Users/manav/Documents/codes/FESystemOld/FESystem/src/Solvers/ArpackEigenSolver.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">fesystem
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_9e51036813d6151dfecc72d5fa7c02b3.html">Users</a>      </li>
      <li class="navelem"><a class="el" href="dir_0c900164955ce081ffb4c6b051e456bf.html">manav</a>      </li>
      <li class="navelem"><a class="el" href="dir_1c27e0e86d47954644c3da6ab29e89d2.html">Documents</a>      </li>
      <li class="navelem"><a class="el" href="dir_702da5bd4e2e61517788da49174c071d.html">codes</a>      </li>
      <li class="navelem"><a class="el" href="dir_549ad45c2f63d8c1db46ab790c4cde83.html">FESystemOld</a>      </li>
      <li class="navelem"><a class="el" href="dir_fa1b40415469e23c583052e363adf212.html">FESystem</a>      </li>
      <li class="navelem"><a class="el" href="dir_f94e632e97ff28080483f5ca56254f08.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_ed26094a524a5f6ffa67b8dd9656adc9.html">Solvers</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ArpackEigenSolver.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_arpack_eigen_solver_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// $Id: ArpackEigenSolver.h,v 1.1.4.4 2007-05-11 05:16:54 manav Exp $</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#ifndef __fesystem_arpack_eigen_solver_h__</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor">#define __fesystem_arpack_eigen_solver_h__</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span>
<a name="l00006"></a>00006 <span class="comment">// C++ includes</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">// FESystem includes</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="_eigen_solver_8h.html">Solvers/EigenSolver.h</a>&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;<a class="code" href="_linear_solver_8h.html">Solvers/LinearSolver.h</a>&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;<a class="code" href="_f_e_system_config_8h.html">FESystem/FESystemConfig.h</a>&quot;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="comment">// libMesh includes</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;numerics/petsc_matrix.h&quot;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l00020"></a>00020 {
<a name="l00021"></a>00021   <span class="comment">/*</span>
<a name="l00022"></a>00022 <span class="comment">   c++ version of ARPACK routine dsaupd that implements a variant of</span>
<a name="l00023"></a>00023 <span class="comment">   the Lanczos method.  This method has been designed to compute</span>
<a name="l00024"></a>00024 <span class="comment">   approximations to a few eigenpairs of a linear operator OP that is</span>
<a name="l00025"></a>00025 <span class="comment">   real and symmetric with respect to a real positive semi-definite</span>
<a name="l00026"></a>00026 <span class="comment">   symmetric matrix B, i.e.</span>
<a name="l00027"></a>00027 <span class="comment">   </span>
<a name="l00028"></a>00028 <span class="comment">   B*OP = (OP&#39;)*B.</span>
<a name="l00029"></a>00029 <span class="comment">   </span>
<a name="l00030"></a>00030 <span class="comment">   where A&#39; denotes transpose of A. In the standard eigenproblem B is</span>
<a name="l00031"></a>00031 <span class="comment">   the identity matrix. Another way to express this condition is</span>
<a name="l00032"></a>00032 <span class="comment">   </span>
<a name="l00033"></a>00033 <span class="comment">   &lt; x,OPy &gt; = &lt; OPx,y &gt;  where &lt; z,w &gt; = z&#39;Bw.</span>
<a name="l00034"></a>00034 <span class="comment">   </span>
<a name="l00035"></a>00035 <span class="comment">   The computed approximate eigenvalues are called Ritz values and</span>
<a name="l00036"></a>00036 <span class="comment">   the corresponding approximate eigenvectors are called Ritz vectors.</span>
<a name="l00037"></a>00037 <span class="comment">   </span>
<a name="l00038"></a>00038 <span class="comment">   saupp is usually called iteratively to solve one of the</span>
<a name="l00039"></a>00039 <span class="comment">   following problems:</span>
<a name="l00040"></a>00040 <span class="comment">   </span>
<a name="l00041"></a>00041 <span class="comment">   Mode 1:  A*x = lambda*x, A symmetric</span>
<a name="l00042"></a>00042 <span class="comment">   ===&gt; OP = A  and  B = I.</span>
<a name="l00043"></a>00043 <span class="comment">   </span>
<a name="l00044"></a>00044 <span class="comment">   Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite</span>
<a name="l00045"></a>00045 <span class="comment">   ===&gt; OP = inv[M]*A  and  B = M.</span>
<a name="l00046"></a>00046 <span class="comment">   ===&gt; (If M can be factored see remark 3 below)</span>
<a name="l00047"></a>00047 <span class="comment">   </span>
<a name="l00048"></a>00048 <span class="comment">   Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite</span>
<a name="l00049"></a>00049 <span class="comment">   ===&gt; OP = (inv[K - sigma*M])*M  and  B = M.</span>
<a name="l00050"></a>00050 <span class="comment">   ===&gt; Shift-and-Invert mode</span>
<a name="l00051"></a>00051 <span class="comment">   </span>
<a name="l00052"></a>00052 <span class="comment">   Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite,</span>
<a name="l00053"></a>00053 <span class="comment">   KG symmetric indefinite</span>
<a name="l00054"></a>00054 <span class="comment">   ===&gt; OP = (inv[K - sigma*KG])*K  and  B = K.</span>
<a name="l00055"></a>00055 <span class="comment">   ===&gt; Buckling mode</span>
<a name="l00056"></a>00056 <span class="comment">   </span>
<a name="l00057"></a>00057 <span class="comment">   Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite</span>
<a name="l00058"></a>00058 <span class="comment">   ===&gt; OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.</span>
<a name="l00059"></a>00059 <span class="comment">   ===&gt; Cayley transformed mode</span>
<a name="l00060"></a>00060 <span class="comment">   </span>
<a name="l00061"></a>00061 <span class="comment">   NOTE: The action of w &lt;- inv[A - sigma*M]*v or w &lt;- inv[M]*v should be</span>
<a name="l00062"></a>00062 <span class="comment">   accomplished either by a direct method using a sparse matrix</span>
<a name="l00063"></a>00063 <span class="comment">   factorization and solving</span>
<a name="l00064"></a>00064 <span class="comment">   </span>
<a name="l00065"></a>00065 <span class="comment">   [A - sigma*M]*w = v  or M*w = v,</span>
<a name="l00066"></a>00066 <span class="comment">   </span>
<a name="l00067"></a>00067 <span class="comment">   or through an iterative method for solving these systems.  If an</span>
<a name="l00068"></a>00068 <span class="comment">   iterative method is used, the convergence test must be more</span>
<a name="l00069"></a>00069 <span class="comment">   stringent than the accuracy requirements for the eigenvalue</span>
<a name="l00070"></a>00070 <span class="comment">   approximations.</span>
<a name="l00071"></a>00071 <span class="comment">   </span>
<a name="l00072"></a>00072 <span class="comment">   Parameters:</span>
<a name="l00073"></a>00073 <span class="comment">   </span>
<a name="l00074"></a>00074 <span class="comment">   ido     (Input / Output) Reverse communication flag.  ido must be</span>
<a name="l00075"></a>00075 <span class="comment">   zero on the first call to saupp.  ido will be set</span>
<a name="l00076"></a>00076 <span class="comment">   internally to indicate the type of operation to be</span>
<a name="l00077"></a>00077 <span class="comment">   performed.  Control is then given back to the calling</span>
<a name="l00078"></a>00078 <span class="comment">   routine which has the responsibility to carry out the</span>
<a name="l00079"></a>00079 <span class="comment">   requested operation and call saupp with the result. The</span>
<a name="l00080"></a>00080 <span class="comment">   operand is given in workd[ipntr[1]], the result must be</span>
<a name="l00081"></a>00081 <span class="comment">   put in workd[ipntr[2]]. (If Mode = 2 see remark 5 below).</span>
<a name="l00082"></a>00082 <span class="comment">   ido =  0: first call to the reverse communication interface.</span>
<a name="l00083"></a>00083 <span class="comment">   ido = -1: compute  Y = OP * X  where</span>
<a name="l00084"></a>00084 <span class="comment">   ipntr[1] is the pointer into workd for X,</span>
<a name="l00085"></a>00085 <span class="comment">   ipntr[2] is the pointer into workd for Y.</span>
<a name="l00086"></a>00086 <span class="comment">   This is for the initialization phase to force the</span>
<a name="l00087"></a>00087 <span class="comment">   starting vector into the range of OP.</span>
<a name="l00088"></a>00088 <span class="comment">   ido =  1: compute  Y = OP * X where</span>
<a name="l00089"></a>00089 <span class="comment">   ipntr[1] is the pointer into workd for X,</span>
<a name="l00090"></a>00090 <span class="comment">   ipntr[2] is the pointer into workd for Y.</span>
<a name="l00091"></a>00091 <span class="comment">   In mode 3,4 and 5, the vector B * X is already</span>
<a name="l00092"></a>00092 <span class="comment">   available in workd[ipntr[3]].  It does not</span>
<a name="l00093"></a>00093 <span class="comment">   need to be recomputed in forming OP * X.</span>
<a name="l00094"></a>00094 <span class="comment">   ido =  2: compute  Y = B * X  where</span>
<a name="l00095"></a>00095 <span class="comment">   ipntr[1] is the pointer into workd for X,</span>
<a name="l00096"></a>00096 <span class="comment">   ipntr[2] is the pointer into workd for Y.</span>
<a name="l00097"></a>00097 <span class="comment">   ido =  3: compute the iparam[8] shifts where</span>
<a name="l00098"></a>00098 <span class="comment">   ipntr[11] is the pointer into workl for</span>
<a name="l00099"></a>00099 <span class="comment">   placing the shifts. See remark 6 below.</span>
<a name="l00100"></a>00100 <span class="comment">   ido = 99: done.</span>
<a name="l00101"></a>00101 <span class="comment">   bmat    (Input) bmat specifies the type of the matrix B that defines</span>
<a name="l00102"></a>00102 <span class="comment">   the semi-inner product for the operator OP.</span>
<a name="l00103"></a>00103 <span class="comment">   bmat = &#39;I&#39; -&gt; standard eigenvalue problem A*x = lambda*x;</span>
<a name="l00104"></a>00104 <span class="comment">   bmat = &#39;G&#39; -&gt; generalized eigenvalue problem A*x = lambda*B*x.</span>
<a name="l00105"></a>00105 <span class="comment">   n       (Input) Dimension of the eigenproblem.</span>
<a name="l00106"></a>00106 <span class="comment">   nev     (Input) Number of eigenvalues to be computed. 0 &lt; nev &lt; n.</span>
<a name="l00107"></a>00107 <span class="comment">   which   (Input) Specify which of the Ritz values of OP to compute.</span>
<a name="l00108"></a>00108 <span class="comment">   &#39;LA&#39; - compute the nev largest (algebraic) eigenvalues.</span>
<a name="l00109"></a>00109 <span class="comment">   &#39;SA&#39; - compute the nev smallest (algebraic) eigenvalues.</span>
<a name="l00110"></a>00110 <span class="comment">   &#39;LM&#39; - compute the nev largest (in magnitude) eigenvalues.</span>
<a name="l00111"></a>00111 <span class="comment">   &#39;SM&#39; - compute the nev smallest (in magnitude) eigenvalues.</span>
<a name="l00112"></a>00112 <span class="comment">   &#39;BE&#39; - compute nev eigenvalues, half from each end of the</span>
<a name="l00113"></a>00113 <span class="comment">   spectrum.  When NEV is odd, compute one more from the</span>
<a name="l00114"></a>00114 <span class="comment">   high end than from the low end.</span>
<a name="l00115"></a>00115 <span class="comment">   (see remark 1 below)</span>
<a name="l00116"></a>00116 <span class="comment">   tol     (Input) Stopping criterion: the relative accuracy of the</span>
<a name="l00117"></a>00117 <span class="comment">   Ritz value is considered acceptable if BOUNDS[i] &lt;=</span>
<a name="l00118"></a>00118 <span class="comment">   tol*abs(RITZ[i]). If tol&lt;=0.0 is passed, the machine</span>
<a name="l00119"></a>00119 <span class="comment">   precision as computed by the LAPACK auxiliary subroutine</span>
<a name="l00120"></a>00120 <span class="comment">   _LAMCH is used.</span>
<a name="l00121"></a>00121 <span class="comment">   resid   (Input / Output) Array of length n.</span>
<a name="l00122"></a>00122 <span class="comment">   On input:</span>
<a name="l00123"></a>00123 <span class="comment">   If info==0, a random initial residual vector is used.</span>
<a name="l00124"></a>00124 <span class="comment">   If info!=0, resid contains the initial residual vector,</span>
<a name="l00125"></a>00125 <span class="comment">   possibly from a previous run.</span>
<a name="l00126"></a>00126 <span class="comment">   On output:</span>
<a name="l00127"></a>00127 <span class="comment">   resid contains the final residual vector.</span>
<a name="l00128"></a>00128 <span class="comment">   ncv     (Input) Number of Lanczos vectors that are generated at each</span>
<a name="l00129"></a>00129 <span class="comment">   iteration. After the startup phase in which nev Lanczos</span>
<a name="l00130"></a>00130 <span class="comment">   vectors are generated, the algorithm generates ncv-nev</span>
<a name="l00131"></a>00131 <span class="comment">   Lanczos vectors at each subsequent update iteration. Most of</span>
<a name="l00132"></a>00132 <span class="comment">   the cost in generating each Lanczos vector is in the</span>
<a name="l00133"></a>00133 <span class="comment">   matrix-vector product OP*x. (See remark 4 below).</span>
<a name="l00134"></a>00134 <span class="comment">   V       (Output) Double precision array of length ncv*n+1. V contains</span>
<a name="l00135"></a>00135 <span class="comment">   the ncv Lanczos basis vectors. The first element V[0] is never</span>
<a name="l00136"></a>00136 <span class="comment">   referenced.</span>
<a name="l00137"></a>00137 <span class="comment">   ldv     (Input) Dimension of the basis vectors contianed in V. This</span>
<a name="l00138"></a>00138 <span class="comment">   parameter MUST be set to n.</span>
<a name="l00139"></a>00139 <span class="comment">   iparam  (Input / Output) Array of length 12.</span>
<a name="l00140"></a>00140 <span class="comment">   iparam[1]  = ISHIFT: method for selecting the implicit shifts.</span>
<a name="l00141"></a>00141 <span class="comment">   The shifts selected at each iteration are used to restart</span>
<a name="l00142"></a>00142 <span class="comment">   the Arnoldi iteration in an implicit fashion.</span>
<a name="l00143"></a>00143 <span class="comment">   -------------------------------------------------------------</span>
<a name="l00144"></a>00144 <span class="comment">   ISHIFT = 0: the shifts are provided by the user via</span>
<a name="l00145"></a>00145 <span class="comment">   reverse communication.  The NCV eigenvalues of</span>
<a name="l00146"></a>00146 <span class="comment">   the current tridiagonal matrix T are returned in</span>
<a name="l00147"></a>00147 <span class="comment">   the part of workl array corresponding to RITZ.</span>
<a name="l00148"></a>00148 <span class="comment">   See remark 6 below.</span>
<a name="l00149"></a>00149 <span class="comment">   ISHIFT = 1: exact shifts with respect to the reduced</span>
<a name="l00150"></a>00150 <span class="comment">   tridiagonal matrix T.  This is equivalent to</span>
<a name="l00151"></a>00151 <span class="comment">   restarting the iteration with a starting vector</span>
<a name="l00152"></a>00152 <span class="comment">   that is a linear combination of Ritz vectors</span>
<a name="l00153"></a>00153 <span class="comment">   associated with the &quot;wanted&quot; Ritz values.</span>
<a name="l00154"></a>00154 <span class="comment">   -------------------------------------------------------------</span>
<a name="l00155"></a>00155 <span class="comment">   iparam[2] is no longer referenced.</span>
<a name="l00156"></a>00156 <span class="comment">   iparam[3]  = MXITER</span>
<a name="l00157"></a>00157 <span class="comment">   On INPUT:  maximum number of Arnoldi update iterations allowed.</span>
<a name="l00158"></a>00158 <span class="comment">   On OUTPUT: actual number of Arnoldi update iterations taken.</span>
<a name="l00159"></a>00159 <span class="comment">   iparam[4]  = NB: blocksize to be used in the recurrence.</span>
<a name="l00160"></a>00160 <span class="comment">   The code currently works only for NB = 1.</span>
<a name="l00161"></a>00161 <span class="comment">   iparam[5]  = NCONV: number of &quot;converged&quot; Ritz values.</span>
<a name="l00162"></a>00162 <span class="comment">   This represents the number of Ritz values that satisfy</span>
<a name="l00163"></a>00163 <span class="comment">   the convergence criterion.</span>
<a name="l00164"></a>00164 <span class="comment">   iparam[6] is no longer referenced.</span>
<a name="l00165"></a>00165 <span class="comment">   iparam[7]  = MODE. On INPUT determines what type of</span>
<a name="l00166"></a>00166 <span class="comment">   eigenproblem is being solved. Must be 1,2,3,4,5.</span>
<a name="l00167"></a>00167 <span class="comment">   iparam[8]  = NP. When ido = 3 and the user provides shifts</span>
<a name="l00168"></a>00168 <span class="comment">   through reverse communication (iparam[1]=0), saupp returns</span>
<a name="l00169"></a>00169 <span class="comment">   NP, the number of shifts the user is to provide.</span>
<a name="l00170"></a>00170 <span class="comment">   0 &lt; NP &lt;=ncv-nev. See Remark 6 below.</span>
<a name="l00171"></a>00171 <span class="comment">   iparam[9]  =  total number of OP*x operations.</span>
<a name="l00172"></a>00172 <span class="comment">   iparam[10] = total number of B*x operations if bmat=&#39;G&#39;.</span>
<a name="l00173"></a>00173 <span class="comment">   iparam[11] = total number of steps of re-orthogonalization.</span>
<a name="l00174"></a>00174 <span class="comment">   ipntr   (Output) Array of length 12. Pointer to mark the starting</span>
<a name="l00175"></a>00175 <span class="comment">   locations in the workd and workl arrays for matrices/vectors</span>
<a name="l00176"></a>00176 <span class="comment">   used by the Lanczos iteration.</span>
<a name="l00177"></a>00177 <span class="comment">   ipntr[1] : pointer to the current operand vector X in workd.</span>
<a name="l00178"></a>00178 <span class="comment">   ipntr[2] : pointer to the current result vector Y in workd.</span>
<a name="l00179"></a>00179 <span class="comment">   ipntr[3] : pointer to the vector B * X in workd when used in</span>
<a name="l00180"></a>00180 <span class="comment">   the shift-and-invert mode.</span>
<a name="l00181"></a>00181 <span class="comment">   ipntr[4] : pointer to the next available location in workl</span>
<a name="l00182"></a>00182 <span class="comment">   that is untouched by the program.</span>
<a name="l00183"></a>00183 <span class="comment">   ipntr[5] : pointer to the ncv by 2 tridiagonal matrix T in</span>
<a name="l00184"></a>00184 <span class="comment">   workl.</span>
<a name="l00185"></a>00185 <span class="comment">   ipntr[6] : pointer to the ncv RITZ values array in workl.</span>
<a name="l00186"></a>00186 <span class="comment">   ipntr[7] : pointer to the Ritz estimates in array workl</span>
<a name="l00187"></a>00187 <span class="comment">   associated with the Ritz values located in RITZ</span>
<a name="l00188"></a>00188 <span class="comment">   in workl.</span>
<a name="l00189"></a>00189 <span class="comment">   ipntr[11]: pointer to the np shifts in workl. See Remark 6.</span>
<a name="l00190"></a>00190 <span class="comment">   Note: ipntr[8:10] is only referenced by seupp. See Remark 2.</span>
<a name="l00191"></a>00191 <span class="comment">   ipntr[8] : pointer to the ncv RITZ values of the original</span>
<a name="l00192"></a>00192 <span class="comment">   system.</span>
<a name="l00193"></a>00193 <span class="comment">   ipntr[9] : pointer to the ncv corresponding error bounds.</span>
<a name="l00194"></a>00194 <span class="comment">   ipntr[10]: pointer to the ncv by ncv matrix of eigenvectors</span>
<a name="l00195"></a>00195 <span class="comment">   of the tridiagonal matrix T. Only referenced by</span>
<a name="l00196"></a>00196 <span class="comment">   seupp if RVEC = TRUE. See Remarks.</span>
<a name="l00197"></a>00197 <span class="comment">   workd   (Input / Output) Array of length 3*N+1.</span>
<a name="l00198"></a>00198 <span class="comment">   Distributed array to be used in the basic Arnoldi iteration</span>
<a name="l00199"></a>00199 <span class="comment">   for reverse communication.  The user should not use workd as</span>
<a name="l00200"></a>00200 <span class="comment">   temporary workspace during the iteration. Upon termination</span>
<a name="l00201"></a>00201 <span class="comment">   workd[1:n] contains B*resid[1:n]. If the Ritz vectors are</span>
<a name="l00202"></a>00202 <span class="comment">   desired subroutine seupp uses this output.</span>
<a name="l00203"></a>00203 <span class="comment">   workl   (Output) Array of length lworkl+1. Private (replicated) array</span>
<a name="l00204"></a>00204 <span class="comment">   on each PE or array allocated on the front end.</span>
<a name="l00205"></a>00205 <span class="comment">   lworkl  (Input) lworkl must be at least ncv*(ncv+8).</span>
<a name="l00206"></a>00206 <span class="comment">   info    (Input / Output) On input, if info = 0, a randomly initial</span>
<a name="l00207"></a>00207 <span class="comment">   residual vector is used, otherwise resid contains the initial</span>
<a name="l00208"></a>00208 <span class="comment">   residual vector, possibly from a previous run.</span>
<a name="l00209"></a>00209 <span class="comment">   On output, info works as a error flag:</span>
<a name="l00210"></a>00210 <span class="comment">   =  0   : Normal exit.</span>
<a name="l00211"></a>00211 <span class="comment">   =  1   : Maximum number of iterations taken. All possible</span>
<a name="l00212"></a>00212 <span class="comment">   eigenvalues of OP has been found. iparam[5]</span>
<a name="l00213"></a>00213 <span class="comment">   returns the number of wanted converged Ritz values.</span>
<a name="l00214"></a>00214 <span class="comment">   =  3   : No shifts could be applied during a cycle of the</span>
<a name="l00215"></a>00215 <span class="comment">   Implicitly restarted Arnoldi iteration. One</span>
<a name="l00216"></a>00216 <span class="comment">   possibility is to increase the size of NCV relative</span>
<a name="l00217"></a>00217 <span class="comment">   to nev. See remark 4 below.</span>
<a name="l00218"></a>00218 <span class="comment">   = -1   : n must be positive.</span>
<a name="l00219"></a>00219 <span class="comment">   = -2   : nev must be positive.</span>
<a name="l00220"></a>00220 <span class="comment">   = -3   : ncv must satisfy nev &lt; ncv &lt;= n.</span>
<a name="l00221"></a>00221 <span class="comment">   = -4   : The maximum number of Arnoldi update iterations allowed</span>
<a name="l00222"></a>00222 <span class="comment">   must be greater than zero.</span>
<a name="l00223"></a>00223 <span class="comment">   = -5   : which must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LA&#39;, &#39;SA&#39; or &#39;BE&#39;.</span>
<a name="l00224"></a>00224 <span class="comment">   = -6   : bmat must be one of &#39;I&#39; or &#39;G&#39;.</span>
<a name="l00225"></a>00225 <span class="comment">   = -7   : Length of private work array workl is not sufficient.</span>
<a name="l00226"></a>00226 <span class="comment">   = -8   : Error return from trid. eigenvalue calculation;</span>
<a name="l00227"></a>00227 <span class="comment">   Informational error from LAPACK routine dsteqr.</span>
<a name="l00228"></a>00228 <span class="comment">   = -9   : Starting vector is zero.</span>
<a name="l00229"></a>00229 <span class="comment">   = -10  : iparam[7] must be 1,2,3,4,5.</span>
<a name="l00230"></a>00230 <span class="comment">   = -11  : iparam[7] = 1 and bmat = &#39;G&#39; are incompatible.</span>
<a name="l00231"></a>00231 <span class="comment">   = -12  : iparam[1] must be equal to 0 or 1.</span>
<a name="l00232"></a>00232 <span class="comment">   = -13  : nev and which = &#39;BE&#39; are incompatible.</span>
<a name="l00233"></a>00233 <span class="comment">   = -9999: Could not build an Arnoldi factorization. iparam[5]</span>
<a name="l00234"></a>00234 <span class="comment">   returns the size of the current Arnoldi factorization.</span>
<a name="l00235"></a>00235 <span class="comment">   The user is advised to check that enough workspace</span>
<a name="l00236"></a>00236 <span class="comment">   and array storage has been allocated.</span>
<a name="l00237"></a>00237 <span class="comment">   </span>
<a name="l00238"></a>00238 <span class="comment">   Remarks:</span>
<a name="l00239"></a>00239 <span class="comment">   1. The converged Ritz values are always returned in ascending</span>
<a name="l00240"></a>00240 <span class="comment">   algebraic order.  The computed Ritz values are approximate</span>
<a name="l00241"></a>00241 <span class="comment">   eigenvalues of OP.  The selection of &quot;which&quot; should be made</span>
<a name="l00242"></a>00242 <span class="comment">   with this in mind when Mode = 3,4,5.  After convergence,</span>
<a name="l00243"></a>00243 <span class="comment">   approximate eigenvalues of the original problem may be obtained</span>
<a name="l00244"></a>00244 <span class="comment">   with the ARPACK subroutine seupp.</span>
<a name="l00245"></a>00245 <span class="comment">   2. If the Ritz vectors corresponding to the converged Ritz values are</span>
<a name="l00246"></a>00246 <span class="comment">   needed, the user must call seupp immediately following completion</span>
<a name="l00247"></a>00247 <span class="comment">   of saupp. This is new starting with version 2.1 of ARPACK.</span>
<a name="l00248"></a>00248 <span class="comment">   3. If M can be factored into a Cholesky factorization M = LL&#39;</span>
<a name="l00249"></a>00249 <span class="comment">   then Mode = 2 should not be selected.  Instead one should use</span>
<a name="l00250"></a>00250 <span class="comment">   Mode = 1 with  OP = inv(L)*A*inv(L&#39;).  Appropriate triangular</span>
<a name="l00251"></a>00251 <span class="comment">   linear systems should be solved with L and L&#39; rather</span>
<a name="l00252"></a>00252 <span class="comment">   than computing inverses.  After convergence, an approximate</span>
<a name="l00253"></a>00253 <span class="comment">   eigenvector z of the original problem is recovered by solving</span>
<a name="l00254"></a>00254 <span class="comment">   L&#39;z = x  where x is a Ritz vector of OP.</span>
<a name="l00255"></a>00255 <span class="comment">   4. At present there is no a-priori analysis to guide the selection</span>
<a name="l00256"></a>00256 <span class="comment">   of ncv relative to nev.  The only formal requrement is that</span>
<a name="l00257"></a>00257 <span class="comment">   ncv &gt; nev. However, it is recommended that ncv &gt;= 2*nev. If many</span>
<a name="l00258"></a>00258 <span class="comment">   problems of the same type are to be solved, one should experiment</span>
<a name="l00259"></a>00259 <span class="comment">   with increasing ncv while keeping nev fixed for a given test</span>
<a name="l00260"></a>00260 <span class="comment">   problem. This will usually decrease the required number of OP*x</span>
<a name="l00261"></a>00261 <span class="comment">   operations but it also increases the work and storage required to</span>
<a name="l00262"></a>00262 <span class="comment">   maintain the orthogonal basis vectors.   The optimal &quot;cross-over&quot;</span>
<a name="l00263"></a>00263 <span class="comment">   with respect to CPU time is problem dependent and must be</span>
<a name="l00264"></a>00264 <span class="comment">   determined empirically.</span>
<a name="l00265"></a>00265 <span class="comment">   5. If iparam[7] = 2 then in the Reverse commuication interface the</span>
<a name="l00266"></a>00266 <span class="comment">   user must do the following. When ido = 1, Y = OP * X is to be</span>
<a name="l00267"></a>00267 <span class="comment">   computed. When iparam[7] = 2 OP = inv(B)*A. After computing A*X</span>
<a name="l00268"></a>00268 <span class="comment">   the user must overwrite X with A*X. Y is then the solution to the</span>
<a name="l00269"></a>00269 <span class="comment">   linear set of equations B*Y = A*X.</span>
<a name="l00270"></a>00270 <span class="comment">   6. When iparam[1] = 0, and ido = 3, the user needs to provide the</span>
<a name="l00271"></a>00271 <span class="comment">   NP = iparam[8] shifts in locations:</span>
<a name="l00272"></a>00272 <span class="comment">   1   workl[ipntr[11]]</span>
<a name="l00273"></a>00273 <span class="comment">   2   workl[ipntr[11]+1]</span>
<a name="l00274"></a>00274 <span class="comment">   .</span>
<a name="l00275"></a>00275 <span class="comment">   .</span>
<a name="l00276"></a>00276 <span class="comment">   .</span>
<a name="l00277"></a>00277 <span class="comment">   NP  workl[ipntr[11]+NP-1].</span>
<a name="l00278"></a>00278 <span class="comment">   The eigenvalues of the current tridiagonal matrix are located in</span>
<a name="l00279"></a>00279 <span class="comment">   workl[ipntr[6]] through workl[ipntr[6]+ncv]. They are in the</span>
<a name="l00280"></a>00280 <span class="comment">   order defined by which. The associated Ritz estimates are located in</span>
<a name="l00281"></a>00281 <span class="comment">   workl[ipntr[8]], workl[ipntr[8]+1], ... , workl[ipntr[8]+ncv-1].</span>
<a name="l00282"></a>00282 <span class="comment">   */</span>
<a name="l00283"></a>00283   <span class="comment">/*  </span>
<a name="l00284"></a>00284 <span class="comment">   call this function as </span>
<a name="l00285"></a>00285 <span class="comment">   dsaupd__(&amp;ido, &amp;bmat, &amp;n, which, &amp;nev, &amp;tol, resid, &amp;ncv,</span>
<a name="l00286"></a>00286 <span class="comment">   &amp;V[1], &amp;ldv, &amp;iparam[1], &amp;ipntr[1], &amp;workd[1], &amp;workl[1],</span>
<a name="l00287"></a>00287 <span class="comment">   &amp;lworkl, &amp;info);</span>
<a name="l00288"></a>00288 <span class="comment">   */</span>
<a name="l00289"></a>00289   
<a name="l00290"></a><a class="code" href="_arpack_eigen_solver_8h.html#a05417caea45e8644016c6995591bf8c1">00290</a>   <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="_f_e_system_config_8h.html#a5bf86bf228b4805fd9efbe403518ecd5">FC_FUNC</a>(dsaupd, DSAUPD)(<span class="keywordtype">int</span> *ido, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae169dc7c559f7af8031a367ca498c4cb">bmat</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aea1409bb93d418b91433540cbb22abc5">n</a>, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab695fb9382c8413b077bbe8d62fce5b6">which</a>,
<a name="l00291"></a>00291                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab8e386cc2c858827a0fab5aa19c51221">nev</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#adfa450f6854e6cb79b651f5ea37cc0d7">tol</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae3bea2bcd8aee5cc2306f8b015fdc69f">resid</a>,
<a name="l00292"></a>00292                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a4ea189c81e56ea26da24f4595139e248">ncv</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ac29db3dbb9b137ecb580f1dfeead0a1c">V</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a3ed32aee215e804a153ab56f9f12de6e">ldv</a>,
<a name="l00293"></a>00293                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a76f18698bf6be53202825afcf7e7ab44">iparam</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a27062ce0b07ecfa619748b16454161ae">ipntr</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a87f692b4c346d37e7718f6856c201e52">workd</a>,
<a name="l00294"></a>00294                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a05417caea45e8644016c6995591bf8c1">workl</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a72c793afa6be02aafd463a92b794b2ff">lworkl</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab4bdba131592d57176f37f9670deec34">info</a>);
<a name="l00295"></a>00295   
<a name="l00296"></a>00296   <span class="comment">/*</span>
<a name="l00297"></a>00297 <span class="comment">   c++ version of ARPACK routine dseupd.</span>
<a name="l00298"></a>00298 <span class="comment">   This subroutine returns the converged approximations to eigenvalues</span>
<a name="l00299"></a>00299 <span class="comment">   of A*z = lambda*B*z and (optionally):</span>
<a name="l00300"></a>00300 <span class="comment">   </span>
<a name="l00301"></a>00301 <span class="comment">   (1) the corresponding approximate eigenvectors,</span>
<a name="l00302"></a>00302 <span class="comment">   (2) an orthonormal (Lanczos) basis for the associated approximate</span>
<a name="l00303"></a>00303 <span class="comment">   invariant subspace,</span>
<a name="l00304"></a>00304 <span class="comment">   </span>
<a name="l00305"></a>00305 <span class="comment">   There is negligible additional cost to obtain eigenvectors. An orthonormal</span>
<a name="l00306"></a>00306 <span class="comment">   (Lanczos) basis is always computed.  There is an additional storage cost</span>
<a name="l00307"></a>00307 <span class="comment">   of n*nev if both are requested (in this case a separate array Z must be</span>
<a name="l00308"></a>00308 <span class="comment">   supplied).</span>
<a name="l00309"></a>00309 <span class="comment">   These quantities are obtained from the Lanczos factorization computed</span>
<a name="l00310"></a>00310 <span class="comment">   by saupp for the linear operator OP prescribed by the MODE selection</span>
<a name="l00311"></a>00311 <span class="comment">   (see IPARAM[7] in saupp documentation). saupp must be called before</span>
<a name="l00312"></a>00312 <span class="comment">   this routine is called. These approximate eigenvalues and vectors are</span>
<a name="l00313"></a>00313 <span class="comment">   commonly called Ritz values and Ritz vectors respectively.  They are</span>
<a name="l00314"></a>00314 <span class="comment">   referred to as such in the comments that follow. The computed orthonormal</span>
<a name="l00315"></a>00315 <span class="comment">   basis for the invariant subspace corresponding to these Ritz values is</span>
<a name="l00316"></a>00316 <span class="comment">   referred to as a Lanczos basis.</span>
<a name="l00317"></a>00317 <span class="comment">   See documentation in the header of the subroutine dsaupp for a definition</span>
<a name="l00318"></a>00318 <span class="comment">   of OP as well as other terms and the relation of computed Ritz values</span>
<a name="l00319"></a>00319 <span class="comment">   and vectors of OP with respect to the given problem  A*z = lambda*B*z.</span>
<a name="l00320"></a>00320 <span class="comment">   The approximate eigenvalues of the original problem are returned in</span>
<a name="l00321"></a>00321 <span class="comment">   ascending algebraic order.  The user may elect to call this routine</span>
<a name="l00322"></a>00322 <span class="comment">   once for each desired Ritz vector and store it peripherally if desired.</span>
<a name="l00323"></a>00323 <span class="comment">   There is also the option of computing a selected set of these vectors</span>
<a name="l00324"></a>00324 <span class="comment">   with a single call.</span>
<a name="l00325"></a>00325 <span class="comment">   </span>
<a name="l00326"></a>00326 <span class="comment">   Parameters:</span>
<a name="l00327"></a>00327 <span class="comment">   </span>
<a name="l00328"></a>00328 <span class="comment">   rvec    (Input) Specifies whether Ritz vectors corresponding to the</span>
<a name="l00329"></a>00329 <span class="comment">   Ritz value approximations to the eigenproblem A*z = lambda*B*z</span>
<a name="l00330"></a>00330 <span class="comment">   are computed.</span>
<a name="l00331"></a>00331 <span class="comment">   rvec = false: Compute Ritz values only.</span>
<a name="l00332"></a>00332 <span class="comment">   rvec = true : Compute Ritz vectors.</span>
<a name="l00333"></a>00333 <span class="comment">   HowMny  (Input) Specifies how many Ritz vectors are wanted and the</span>
<a name="l00334"></a>00334 <span class="comment">   form of Z, the matrix of Ritz vectors. See remark 1 below.</span>
<a name="l00335"></a>00335 <span class="comment">   The only option already implemented is HowMny = &#39;A&#39;.</span>
<a name="l00336"></a>00336 <span class="comment">   d       (Output) Array of dimension nev. On exit, d contains the Ritz</span>
<a name="l00337"></a>00337 <span class="comment">   value approximations to the eigenvalues of A*z = lambda*B*z.</span>
<a name="l00338"></a>00338 <span class="comment">   The values are returned in ascending order. If iparam[7] =</span>
<a name="l00339"></a>00339 <span class="comment">   3, 4, 5 then d represents the Ritz values of OP computed by</span>
<a name="l00340"></a>00340 <span class="comment">   dsaupp transformed to those of the original eigensystem A*z =</span>
<a name="l00341"></a>00341 <span class="comment">   lambda*B*z. If iparam[7] = 1,2 then the Ritz values of OP are</span>
<a name="l00342"></a>00342 <span class="comment">   the same as the those of A*z = lambda*B*z.</span>
<a name="l00343"></a>00343 <span class="comment">   Z       (Output) Array of dimension nev*n if HowMny = &#39;A&#39;. On</span>
<a name="l00344"></a>00344 <span class="comment">   exit, Z contains the B-orthonormal Ritz vectors of the</span>
<a name="l00345"></a>00345 <span class="comment">   eigensystem A*z = lambda*B*z corresponding to the Ritz value</span>
<a name="l00346"></a>00346 <span class="comment">   approximations. If  rvec = false then Z is not referenced.</span>
<a name="l00347"></a>00347 <span class="comment">   NOTE: The array Z may be set equal to first nev columns of</span>
<a name="l00348"></a>00348 <span class="comment">   the Arnoldi/Lanczos basis array V computed by dsaupp.</span>
<a name="l00349"></a>00349 <span class="comment">   ldz     (Input) Dimension of the vectors contained in Z. This</span>
<a name="l00350"></a>00350 <span class="comment">   parameter MUST be set to n.</span>
<a name="l00351"></a>00351 <span class="comment">   sigma   (Input) If iparam[7] = 3,4,5 represents the shift. Not</span>
<a name="l00352"></a>00352 <span class="comment">   referenced if iparam[7] = 1 or 2.</span>
<a name="l00353"></a>00353 <span class="comment">   workl   (Input / Output) Array of length lworkl+1.</span>
<a name="l00354"></a>00354 <span class="comment">   workl[1:4*ncv] contains information obtained in saupp.</span>
<a name="l00355"></a>00355 <span class="comment">   They are not changed by seupp. workl[4*ncv+1:ncv*(ncv+8)]</span>
<a name="l00356"></a>00356 <span class="comment">   holds the untransformed Ritz values, the computed error</span>
<a name="l00357"></a>00357 <span class="comment">   estimates, and the associated eigenvector matrix of H.</span>
<a name="l00358"></a>00358 <span class="comment">   Note: ipntr[8:10] contains the pointer into workl for</span>
<a name="l00359"></a>00359 <span class="comment">   addresses of the above information computed by seupp.</span>
<a name="l00360"></a>00360 <span class="comment">   ipntr   (Input / Output) Array of length 12. Pointer to mark the</span>
<a name="l00361"></a>00361 <span class="comment">   starting locations in the workl array for matrices/vectors</span>
<a name="l00362"></a>00362 <span class="comment">   used by dsaupp and seupp.</span>
<a name="l00363"></a>00363 <span class="comment">   ipntr[8] : pointer to the RITZ values of the original system.</span>
<a name="l00364"></a>00364 <span class="comment">   ipntr[9] : pointer to the ncv corresponding error bounds.</span>
<a name="l00365"></a>00365 <span class="comment">   ipntr[10]: pointer to the ncv by ncv matrix of eigenvectors</span>
<a name="l00366"></a>00366 <span class="comment">   of the tridiagonal matrix T. Only referenced by</span>
<a name="l00367"></a>00367 <span class="comment">   seupp if rvec = true. See Remarks.</span>
<a name="l00368"></a>00368 <span class="comment">   info    (Output) Error flag.</span>
<a name="l00369"></a>00369 <span class="comment">   =  0 : Normal exit.</span>
<a name="l00370"></a>00370 <span class="comment">   = -1 : n must be positive.</span>
<a name="l00371"></a>00371 <span class="comment">   = -2 : nev must be positive.</span>
<a name="l00372"></a>00372 <span class="comment">   = -3 : ncv must satisfy nev &lt; ncv &lt;= n.</span>
<a name="l00373"></a>00373 <span class="comment">   = -5 : which must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LA&#39;, &#39;SA&#39; or &#39;BE&#39;.</span>
<a name="l00374"></a>00374 <span class="comment">   = -6 : bmat must be one of &#39;I&#39; or &#39;G&#39;.</span>
<a name="l00375"></a>00375 <span class="comment">   = -7 : Length of private work workl array is not sufficient.</span>
<a name="l00376"></a>00376 <span class="comment">   = -8 : Error return from trid. eigenvalue calculation;</span>
<a name="l00377"></a>00377 <span class="comment">   Information error from LAPACK routine dsteqr.</span>
<a name="l00378"></a>00378 <span class="comment">   = -9 : Starting vector is zero.</span>
<a name="l00379"></a>00379 <span class="comment">   = -10: iparam[7] must be 1,2,3,4,5.</span>
<a name="l00380"></a>00380 <span class="comment">   = -11: iparam[7] = 1 and bmat = &#39;G&#39; are incompatible.</span>
<a name="l00381"></a>00381 <span class="comment">   = -12: nev and which = &#39;BE&#39; are incompatible.</span>
<a name="l00382"></a>00382 <span class="comment">   = -14: dsaupp did not find any eigenvalues to sufficient</span>
<a name="l00383"></a>00383 <span class="comment">   accuracy.</span>
<a name="l00384"></a>00384 <span class="comment">   = -15: HowMny must be one of &#39;A&#39; or &#39;S&#39; if rvec = true.</span>
<a name="l00385"></a>00385 <span class="comment">   = -16: HowMny = &#39;S&#39; not yet implemented.</span>
<a name="l00386"></a>00386 <span class="comment">   </span>
<a name="l00387"></a>00387 <span class="comment">   NOTE:     The following arguments</span>
<a name="l00388"></a>00388 <span class="comment">   </span>
<a name="l00389"></a>00389 <span class="comment">   bmat, n, which, nev, tol, resid, ncv, V, ldv, iparam,</span>
<a name="l00390"></a>00390 <span class="comment">   ipntr, workd, workl, lworkl, info</span>
<a name="l00391"></a>00391 <span class="comment">   </span>
<a name="l00392"></a>00392 <span class="comment">   must be passed directly to seupp following the last call</span>
<a name="l00393"></a>00393 <span class="comment">   to saupp.  These arguments MUST NOT BE MODIFIED between</span>
<a name="l00394"></a>00394 <span class="comment">   the the last call to saupp and the call to seupp.</span>
<a name="l00395"></a>00395 <span class="comment">   </span>
<a name="l00396"></a>00396 <span class="comment">   Remarks</span>
<a name="l00397"></a>00397 <span class="comment">   1. The converged Ritz values are always returned in increasing</span>
<a name="l00398"></a>00398 <span class="comment">   (algebraic) order.</span>
<a name="l00399"></a>00399 <span class="comment">   2. Currently only HowMny = &#39;A&#39; is implemented. It is included at</span>
<a name="l00400"></a>00400 <span class="comment">   this stage for the user who wants to incorporate it.</span>
<a name="l00401"></a>00401 <span class="comment"></span>
<a name="l00402"></a>00402 <span class="comment">   call this function as: </span>
<a name="l00403"></a>00403 <span class="comment">   F77NAME(dseupd)(&amp;irvec, &amp;HowMny, iselect, d, iZ, &amp;ldz, &amp;sigma, &amp;bmat,</span>
<a name="l00404"></a>00404 <span class="comment">   &amp;n, which, &amp;nev, &amp;tol, resid, &amp;ncv, &amp;V[1], &amp;ldv, &amp;iparam[1],</span>
<a name="l00405"></a>00405 <span class="comment">   &amp;ipntr[1], &amp;workd[1], &amp;workl[1], &amp;lworkl, &amp;info );</span>
<a name="l00406"></a>00406 <span class="comment">   */</span>
<a name="l00407"></a>00407   
<a name="l00408"></a><a class="code" href="_arpack_eigen_solver_8h.html#a540cfc30f381a8ed8eecd97ae19e1f48">00408</a>   <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="_f_e_system_config_8h.html#a5bf86bf228b4805fd9efbe403518ecd5">FC_FUNC</a>(dseupd, DSEUPD)(<span class="keywordtype">int</span> *rvec, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a6a6266aa9975d725fd12991126f47240">HowMny</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aaa210a43690eb16c620f77ad3d85520e">select</a>,
<a name="l00409"></a>00409                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a5b4b214d30ffefbec22a9edf4a91454f">d</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a540cfc30f381a8ed8eecd97ae19e1f48">Z</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aa669ebf7f44e1a79551bcf7c4ef1dfc2">ldz</a>,
<a name="l00410"></a>00410                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ac687728cb5722b5730ca1b1197128920">sigma</a>, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae169dc7c559f7af8031a367ca498c4cb">bmat</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aea1409bb93d418b91433540cbb22abc5">n</a>,
<a name="l00411"></a>00411                                       <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab695fb9382c8413b077bbe8d62fce5b6">which</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab8e386cc2c858827a0fab5aa19c51221">nev</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#adfa450f6854e6cb79b651f5ea37cc0d7">tol</a>,
<a name="l00412"></a>00412                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae3bea2bcd8aee5cc2306f8b015fdc69f">resid</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a4ea189c81e56ea26da24f4595139e248">ncv</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ac29db3dbb9b137ecb580f1dfeead0a1c">V</a>,
<a name="l00413"></a>00413                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a3ed32aee215e804a153ab56f9f12de6e">ldv</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a76f18698bf6be53202825afcf7e7ab44">iparam</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a27062ce0b07ecfa619748b16454161ae">ipntr</a>,
<a name="l00414"></a>00414                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a87f692b4c346d37e7718f6856c201e52">workd</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a05417caea45e8644016c6995591bf8c1">workl</a>,
<a name="l00415"></a>00415                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a72c793afa6be02aafd463a92b794b2ff">lworkl</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab4bdba131592d57176f37f9670deec34">info</a>);
<a name="l00416"></a>00416   
<a name="l00417"></a>00417   <span class="comment">/*</span>
<a name="l00418"></a>00418 <span class="comment">   c\BeginDoc</span>
<a name="l00419"></a>00419 <span class="comment">   c</span>
<a name="l00420"></a>00420 <span class="comment">   c\Name: dnaupd</span>
<a name="l00421"></a>00421 <span class="comment">   c</span>
<a name="l00422"></a>00422 <span class="comment">   c\Description: </span>
<a name="l00423"></a>00423 <span class="comment">   c  Reverse communication interface for the Implicitly Restarted Arnoldi</span>
<a name="l00424"></a>00424 <span class="comment">   c  iteration. This subroutine computes approximations to a few eigenpairs </span>
<a name="l00425"></a>00425 <span class="comment">   c  of a linear operator &quot;OP&quot; with respect to a semi-inner product defined by </span>
<a name="l00426"></a>00426 <span class="comment">   c  a symmetric positive semi-definite real matrix B. B may be the identity </span>
<a name="l00427"></a>00427 <span class="comment">   c  matrix. NOTE: If the linear operator &quot;OP&quot; is real and symmetric </span>
<a name="l00428"></a>00428 <span class="comment">   c  with respect to the real positive semi-definite symmetric matrix B, </span>
<a name="l00429"></a>00429 <span class="comment">   c  i.e. B*OP = (OP`)*B, then subroutine dsaupd should be used instead.</span>
<a name="l00430"></a>00430 <span class="comment">   c</span>
<a name="l00431"></a>00431 <span class="comment">   c  The computed approximate eigenvalues are called Ritz values and</span>
<a name="l00432"></a>00432 <span class="comment">   c  the corresponding approximate eigenvectors are called Ritz vectors.</span>
<a name="l00433"></a>00433 <span class="comment">   c</span>
<a name="l00434"></a>00434 <span class="comment">   c  dnaupd is usually called iteratively to solve one of the </span>
<a name="l00435"></a>00435 <span class="comment">   c  following problems:</span>
<a name="l00436"></a>00436 <span class="comment">   c</span>
<a name="l00437"></a>00437 <span class="comment">   c  Mode 1:  A*x = lambda*x.</span>
<a name="l00438"></a>00438 <span class="comment">   c           ===&gt; OP = A  and  B = I.</span>
<a name="l00439"></a>00439 <span class="comment">   c</span>
<a name="l00440"></a>00440 <span class="comment">   c  Mode 2:  A*x = lambda*M*x, M symmetric positive definite</span>
<a name="l00441"></a>00441 <span class="comment">   c           ===&gt; OP = inv[M]*A  and  B = M.</span>
<a name="l00442"></a>00442 <span class="comment">   c           ===&gt; (If M can be factored see remark 3 below)</span>
<a name="l00443"></a>00443 <span class="comment">   c</span>
<a name="l00444"></a>00444 <span class="comment">   c  Mode 3:  A*x = lambda*M*x, M symmetric semi-definite</span>
<a name="l00445"></a>00445 <span class="comment">   c           ===&gt; OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M. </span>
<a name="l00446"></a>00446 <span class="comment">   c           ===&gt; shift-and-invert mode (in real arithmetic)</span>
<a name="l00447"></a>00447 <span class="comment">   c           If OP*x = amu*x, then </span>
<a name="l00448"></a>00448 <span class="comment">   c           amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].</span>
<a name="l00449"></a>00449 <span class="comment">   c           Note: If sigma is real, i.e. imaginary part of sigma is zero;</span>
<a name="l00450"></a>00450 <span class="comment">   c                 Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M </span>
<a name="l00451"></a>00451 <span class="comment">   c                 amu == 1/(lambda-sigma). </span>
<a name="l00452"></a>00452 <span class="comment">   c  </span>
<a name="l00453"></a>00453 <span class="comment">   c  Mode 4:  A*x = lambda*M*x, M symmetric semi-definite</span>
<a name="l00454"></a>00454 <span class="comment">   c           ===&gt; OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M. </span>
<a name="l00455"></a>00455 <span class="comment">   c           ===&gt; shift-and-invert mode (in real arithmetic)</span>
<a name="l00456"></a>00456 <span class="comment">   c           If OP*x = amu*x, then </span>
<a name="l00457"></a>00457 <span class="comment">   c           amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].</span>
<a name="l00458"></a>00458 <span class="comment">   c</span>
<a name="l00459"></a>00459 <span class="comment">   c  Both mode 3 and 4 give the same enhancement to eigenvalues close to</span>
<a name="l00460"></a>00460 <span class="comment">   c  the (complex) shift sigma.  However, as lambda goes to infinity,</span>
<a name="l00461"></a>00461 <span class="comment">   c  the operator OP in mode 4 dampens the eigenvalues more strongly than</span>
<a name="l00462"></a>00462 <span class="comment">   c  does OP defined in mode 3.</span>
<a name="l00463"></a>00463 <span class="comment">   c</span>
<a name="l00464"></a>00464 <span class="comment">   c  NOTE: The action of w &lt;- inv[A - sigma*M]*v or w &lt;- inv[M]*v</span>
<a name="l00465"></a>00465 <span class="comment">   c        should be accomplished either by a direct method</span>
<a name="l00466"></a>00466 <span class="comment">   c        using a sparse matrix factorization and solving</span>
<a name="l00467"></a>00467 <span class="comment">   c</span>
<a name="l00468"></a>00468 <span class="comment">   c           [A - sigma*M]*w = v  or M*w = v,</span>
<a name="l00469"></a>00469 <span class="comment">   c</span>
<a name="l00470"></a>00470 <span class="comment">   c        or through an iterative method for solving these</span>
<a name="l00471"></a>00471 <span class="comment">   c        systems.  If an iterative method is used, the</span>
<a name="l00472"></a>00472 <span class="comment">   c        convergence test must be more stringent than</span>
<a name="l00473"></a>00473 <span class="comment">   c        the accuracy requirements for the eigenvalue</span>
<a name="l00474"></a>00474 <span class="comment">   c        approximations.</span>
<a name="l00475"></a>00475 <span class="comment">   c</span>
<a name="l00476"></a>00476 <span class="comment">   c\Usage:</span>
<a name="l00477"></a>00477 <span class="comment">   c  call dnaupd</span>
<a name="l00478"></a>00478 <span class="comment">   c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,</span>
<a name="l00479"></a>00479 <span class="comment">   c       IPNTR, WORKD, WORKL, LWORKL, INFO )</span>
<a name="l00480"></a>00480 <span class="comment">   c</span>
<a name="l00481"></a>00481 <span class="comment">   c\Arguments</span>
<a name="l00482"></a>00482 <span class="comment">   c  IDO     Integer.  (INPUT/OUTPUT)</span>
<a name="l00483"></a>00483 <span class="comment">   c          Reverse communication flag.  IDO must be zero on the first </span>
<a name="l00484"></a>00484 <span class="comment">   c          call to dnaupd.  IDO will be set internally to</span>
<a name="l00485"></a>00485 <span class="comment">   c          indicate the type of operation to be performed.  Control is</span>
<a name="l00486"></a>00486 <span class="comment">   c          then given back to the calling routine which has the</span>
<a name="l00487"></a>00487 <span class="comment">   c          responsibility to carry out the requested operation and call</span>
<a name="l00488"></a>00488 <span class="comment">   c          dnaupd with the result.  The operand is given in</span>
<a name="l00489"></a>00489 <span class="comment">   c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).</span>
<a name="l00490"></a>00490 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l00491"></a>00491 <span class="comment">   c          IDO =  0: first call to the reverse communication interface</span>
<a name="l00492"></a>00492 <span class="comment">   c          IDO = -1: compute  Y = OP * X  where</span>
<a name="l00493"></a>00493 <span class="comment">   c                    IPNTR(1) is the pointer into WORKD for X,</span>
<a name="l00494"></a>00494 <span class="comment">   c                    IPNTR(2) is the pointer into WORKD for Y.</span>
<a name="l00495"></a>00495 <span class="comment">   c                    This is for the initialization phase to force the</span>
<a name="l00496"></a>00496 <span class="comment">   c                    starting vector into the range of OP.</span>
<a name="l00497"></a>00497 <span class="comment">   c          IDO =  1: compute  Y = OP * X  where</span>
<a name="l00498"></a>00498 <span class="comment">   c                    IPNTR(1) is the pointer into WORKD for X,</span>
<a name="l00499"></a>00499 <span class="comment">   c                    IPNTR(2) is the pointer into WORKD for Y.</span>
<a name="l00500"></a>00500 <span class="comment">   c                    In mode 3 and 4, the vector B * X is already</span>
<a name="l00501"></a>00501 <span class="comment">   c                    available in WORKD(ipntr(3)).  It does not</span>
<a name="l00502"></a>00502 <span class="comment">   c                    need to be recomputed in forming OP * X.</span>
<a name="l00503"></a>00503 <span class="comment">   c          IDO =  2: compute  Y = B * X  where</span>
<a name="l00504"></a>00504 <span class="comment">   c                    IPNTR(1) is the pointer into WORKD for X,</span>
<a name="l00505"></a>00505 <span class="comment">   c                    IPNTR(2) is the pointer into WORKD for Y.</span>
<a name="l00506"></a>00506 <span class="comment">   c          IDO =  3: compute the IPARAM(8) real and imaginary parts </span>
<a name="l00507"></a>00507 <span class="comment">   c                    of the shifts where INPTR(14) is the pointer</span>
<a name="l00508"></a>00508 <span class="comment">   c                    into WORKL for placing the shifts. See Remark</span>
<a name="l00509"></a>00509 <span class="comment">   c                    5 below.</span>
<a name="l00510"></a>00510 <span class="comment">   c          IDO = 99: done</span>
<a name="l00511"></a>00511 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l00512"></a>00512 <span class="comment">   c             </span>
<a name="l00513"></a>00513 <span class="comment">   c  BMAT    Character*1.  (INPUT)</span>
<a name="l00514"></a>00514 <span class="comment">   c          BMAT specifies the type of the matrix B that defines the</span>
<a name="l00515"></a>00515 <span class="comment">   c          semi-inner product for the operator OP.</span>
<a name="l00516"></a>00516 <span class="comment">   c          BMAT = &#39;I&#39; -&gt; standard eigenvalue problem A*x = lambda*x</span>
<a name="l00517"></a>00517 <span class="comment">   c          BMAT = &#39;G&#39; -&gt; generalized eigenvalue problem A*x = lambda*B*x</span>
<a name="l00518"></a>00518 <span class="comment">   c</span>
<a name="l00519"></a>00519 <span class="comment">   c  N       Integer.  (INPUT)</span>
<a name="l00520"></a>00520 <span class="comment">   c          Dimension of the eigenproblem.</span>
<a name="l00521"></a>00521 <span class="comment">   c</span>
<a name="l00522"></a>00522 <span class="comment">   c  WHICH   Character*2.  (INPUT)</span>
<a name="l00523"></a>00523 <span class="comment">   c          &#39;LM&#39; -&gt; want the NEV eigenvalues of largest magnitude.</span>
<a name="l00524"></a>00524 <span class="comment">   c          &#39;SM&#39; -&gt; want the NEV eigenvalues of smallest magnitude.</span>
<a name="l00525"></a>00525 <span class="comment">   c          &#39;LR&#39; -&gt; want the NEV eigenvalues of largest real part.</span>
<a name="l00526"></a>00526 <span class="comment">   c          &#39;SR&#39; -&gt; want the NEV eigenvalues of smallest real part.</span>
<a name="l00527"></a>00527 <span class="comment">   c          &#39;LI&#39; -&gt; want the NEV eigenvalues of largest imaginary part.</span>
<a name="l00528"></a>00528 <span class="comment">   c          &#39;SI&#39; -&gt; want the NEV eigenvalues of smallest imaginary part.</span>
<a name="l00529"></a>00529 <span class="comment">   c</span>
<a name="l00530"></a>00530 <span class="comment">   c  NEV     Integer.  (INPUT/OUTPUT)</span>
<a name="l00531"></a>00531 <span class="comment">   c          Number of eigenvalues of OP to be computed. 0 &lt; NEV &lt; N-1.</span>
<a name="l00532"></a>00532 <span class="comment">   c</span>
<a name="l00533"></a>00533 <span class="comment">   c  TOL     Double precision scalar.  (INPUT)</span>
<a name="l00534"></a>00534 <span class="comment">   c          Stopping criterion: the relative accuracy of the Ritz value </span>
<a name="l00535"></a>00535 <span class="comment">   c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))</span>
<a name="l00536"></a>00536 <span class="comment">   c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.</span>
<a name="l00537"></a>00537 <span class="comment">   c          DEFAULT = DLAMCH(&#39;EPS&#39;)  (machine precision as computed</span>
<a name="l00538"></a>00538 <span class="comment">   c                    by the LAPACK auxiliary subroutine DLAMCH).</span>
<a name="l00539"></a>00539 <span class="comment">   c</span>
<a name="l00540"></a>00540 <span class="comment">   c  RESID   Double precision array of length N.  (INPUT/OUTPUT)</span>
<a name="l00541"></a>00541 <span class="comment">   c          On INPUT: </span>
<a name="l00542"></a>00542 <span class="comment">   c          If INFO .EQ. 0, a random initial residual vector is used.</span>
<a name="l00543"></a>00543 <span class="comment">   c          If INFO .NE. 0, RESID contains the initial residual vector,</span>
<a name="l00544"></a>00544 <span class="comment">   c                          possibly from a previous run.</span>
<a name="l00545"></a>00545 <span class="comment">   c          On OUTPUT:</span>
<a name="l00546"></a>00546 <span class="comment">   c          RESID contains the final residual vector.</span>
<a name="l00547"></a>00547 <span class="comment">   c</span>
<a name="l00548"></a>00548 <span class="comment">   c  NCV     Integer.  (INPUT)</span>
<a name="l00549"></a>00549 <span class="comment">   c          Number of columns of the matrix V. NCV must satisfy the two</span>
<a name="l00550"></a>00550 <span class="comment">   c          inequalities 2 &lt;= NCV-NEV and NCV &lt;= N.</span>
<a name="l00551"></a>00551 <span class="comment">   c          This will indicate how many Arnoldi vectors are generated </span>
<a name="l00552"></a>00552 <span class="comment">   c          at each iteration.  After the startup phase in which NEV </span>
<a name="l00553"></a>00553 <span class="comment">   c          Arnoldi vectors are generated, the algorithm generates </span>
<a name="l00554"></a>00554 <span class="comment">   c          approximately NCV-NEV Arnoldi vectors at each subsequent update </span>
<a name="l00555"></a>00555 <span class="comment">   c          iteration. Most of the cost in generating each Arnoldi vector is </span>
<a name="l00556"></a>00556 <span class="comment">   c          in the matrix-vector operation OP*x. </span>
<a name="l00557"></a>00557 <span class="comment">   c          NOTE: 2 &lt;= NCV-NEV in order that complex conjugate pairs of Ritz </span>
<a name="l00558"></a>00558 <span class="comment">   c          values are kept together. (See remark 4 below)</span>
<a name="l00559"></a>00559 <span class="comment">   c</span>
<a name="l00560"></a>00560 <span class="comment">   c  V       Double precision array N by NCV.  (OUTPUT)</span>
<a name="l00561"></a>00561 <span class="comment">   c          Contains the final set of Arnoldi basis vectors. </span>
<a name="l00562"></a>00562 <span class="comment">   c</span>
<a name="l00563"></a>00563 <span class="comment">   c  LDV     Integer.  (INPUT)</span>
<a name="l00564"></a>00564 <span class="comment">   c          Leading dimension of V exactly as declared in the calling program.</span>
<a name="l00565"></a>00565 <span class="comment">   c</span>
<a name="l00566"></a>00566 <span class="comment">   c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)</span>
<a name="l00567"></a>00567 <span class="comment">   c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.</span>
<a name="l00568"></a>00568 <span class="comment">   c          The shifts selected at each iteration are used to restart</span>
<a name="l00569"></a>00569 <span class="comment">   c          the Arnoldi iteration in an implicit fashion.</span>
<a name="l00570"></a>00570 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l00571"></a>00571 <span class="comment">   c          ISHIFT = 0: the shifts are provided by the user via</span>
<a name="l00572"></a>00572 <span class="comment">   c                      reverse communication.  The real and imaginary</span>
<a name="l00573"></a>00573 <span class="comment">   c                      parts of the NCV eigenvalues of the Hessenberg</span>
<a name="l00574"></a>00574 <span class="comment">   c                      matrix H are returned in the part of the WORKL </span>
<a name="l00575"></a>00575 <span class="comment">   c                      array corresponding to RITZR and RITZI. See remark </span>
<a name="l00576"></a>00576 <span class="comment">   c                      5 below.</span>
<a name="l00577"></a>00577 <span class="comment">   c          ISHIFT = 1: exact shifts with respect to the current</span>
<a name="l00578"></a>00578 <span class="comment">   c                      Hessenberg matrix H.  This is equivalent to </span>
<a name="l00579"></a>00579 <span class="comment">   c                      restarting the iteration with a starting vector</span>
<a name="l00580"></a>00580 <span class="comment">   c                      that is a linear combination of approximate Schur</span>
<a name="l00581"></a>00581 <span class="comment">   c                      vectors associated with the &quot;wanted&quot; Ritz values.</span>
<a name="l00582"></a>00582 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l00583"></a>00583 <span class="comment">   c</span>
<a name="l00584"></a>00584 <span class="comment">   c          IPARAM(2) = No longer referenced.</span>
<a name="l00585"></a>00585 <span class="comment">   c</span>
<a name="l00586"></a>00586 <span class="comment">   c          IPARAM(3) = MXITER</span>
<a name="l00587"></a>00587 <span class="comment">   c          On INPUT:  maximum number of Arnoldi update iterations allowed. </span>
<a name="l00588"></a>00588 <span class="comment">   c          On OUTPUT: actual number of Arnoldi update iterations taken. </span>
<a name="l00589"></a>00589 <span class="comment">   c</span>
<a name="l00590"></a>00590 <span class="comment">   c          IPARAM(4) = NB: blocksize to be used in the recurrence.</span>
<a name="l00591"></a>00591 <span class="comment">   c          The code currently works only for NB = 1.</span>
<a name="l00592"></a>00592 <span class="comment">   c</span>
<a name="l00593"></a>00593 <span class="comment">   c          IPARAM(5) = NCONV: number of &quot;converged&quot; Ritz values.</span>
<a name="l00594"></a>00594 <span class="comment">   c          This represents the number of Ritz values that satisfy</span>
<a name="l00595"></a>00595 <span class="comment">   c          the convergence criterion.</span>
<a name="l00596"></a>00596 <span class="comment">   c</span>
<a name="l00597"></a>00597 <span class="comment">   c          IPARAM(6) = IUPD</span>
<a name="l00598"></a>00598 <span class="comment">   c          No longer referenced. Implicit restarting is ALWAYS used.  </span>
<a name="l00599"></a>00599 <span class="comment">   c</span>
<a name="l00600"></a>00600 <span class="comment">   c          IPARAM(7) = MODE</span>
<a name="l00601"></a>00601 <span class="comment">   c          On INPUT determines what type of eigenproblem is being solved.</span>
<a name="l00602"></a>00602 <span class="comment">   c          Must be 1,2,3,4; See under \Description of dnaupd for the </span>
<a name="l00603"></a>00603 <span class="comment">   c          four modes available.</span>
<a name="l00604"></a>00604 <span class="comment">   c</span>
<a name="l00605"></a>00605 <span class="comment">   c          IPARAM(8) = NP</span>
<a name="l00606"></a>00606 <span class="comment">   c          When ido = 3 and the user provides shifts through reverse</span>
<a name="l00607"></a>00607 <span class="comment">   c          communication (IPARAM(1)=0), dnaupd returns NP, the number</span>
<a name="l00608"></a>00608 <span class="comment">   c          of shifts the user is to provide. 0 &lt; NP &lt;=NCV-NEV. See Remark</span>
<a name="l00609"></a>00609 <span class="comment">   c          5 below.</span>
<a name="l00610"></a>00610 <span class="comment">   c</span>
<a name="l00611"></a>00611 <span class="comment">   c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,</span>
<a name="l00612"></a>00612 <span class="comment">   c          OUTPUT: NUMOP  = total number of OP*x operations,</span>
<a name="l00613"></a>00613 <span class="comment">   c                  NUMOPB = total number of B*x operations if BMAT=&#39;G&#39;,</span>
<a name="l00614"></a>00614 <span class="comment">   c                  NUMREO = total number of steps of re-orthogonalization.        </span>
<a name="l00615"></a>00615 <span class="comment">   c</span>
<a name="l00616"></a>00616 <span class="comment">   c  IPNTR   Integer array of length 14.  (OUTPUT)</span>
<a name="l00617"></a>00617 <span class="comment">   c          Pointer to mark the starting locations in the WORKD and WORKL</span>
<a name="l00618"></a>00618 <span class="comment">   c          arrays for matrices/vectors used by the Arnoldi iteration.</span>
<a name="l00619"></a>00619 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l00620"></a>00620 <span class="comment">   c          IPNTR(1): pointer to the current operand vector X in WORKD.</span>
<a name="l00621"></a>00621 <span class="comment">   c          IPNTR(2): pointer to the current result vector Y in WORKD.</span>
<a name="l00622"></a>00622 <span class="comment">   c          IPNTR(3): pointer to the vector B * X in WORKD when used in </span>
<a name="l00623"></a>00623 <span class="comment">   c                    the shift-and-invert mode.</span>
<a name="l00624"></a>00624 <span class="comment">   c          IPNTR(4): pointer to the next available location in WORKL</span>
<a name="l00625"></a>00625 <span class="comment">   c                    that is untouched by the program.</span>
<a name="l00626"></a>00626 <span class="comment">   c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix</span>
<a name="l00627"></a>00627 <span class="comment">   c                    H in WORKL.</span>
<a name="l00628"></a>00628 <span class="comment">   c          IPNTR(6): pointer to the real part of the ritz value array </span>
<a name="l00629"></a>00629 <span class="comment">   c                    RITZR in WORKL.</span>
<a name="l00630"></a>00630 <span class="comment">   c          IPNTR(7): pointer to the imaginary part of the ritz value array</span>
<a name="l00631"></a>00631 <span class="comment">   c                    RITZI in WORKL.</span>
<a name="l00632"></a>00632 <span class="comment">   c          IPNTR(8): pointer to the Ritz estimates in array WORKL associated</span>
<a name="l00633"></a>00633 <span class="comment">   c                    with the Ritz values located in RITZR and RITZI in WORKL.</span>
<a name="l00634"></a>00634 <span class="comment">   c</span>
<a name="l00635"></a>00635 <span class="comment">   c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.</span>
<a name="l00636"></a>00636 <span class="comment">   c</span>
<a name="l00637"></a>00637 <span class="comment">   c          Note: IPNTR(9:13) is only referenced by dneupd. See Remark 2 below.</span>
<a name="l00638"></a>00638 <span class="comment">   c</span>
<a name="l00639"></a>00639 <span class="comment">   c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the </span>
<a name="l00640"></a>00640 <span class="comment">   c                     original system.</span>
<a name="l00641"></a>00641 <span class="comment">   c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of </span>
<a name="l00642"></a>00642 <span class="comment">   c                     the original system.</span>
<a name="l00643"></a>00643 <span class="comment">   c          IPNTR(11): pointer to the NCV corresponding error bounds.</span>
<a name="l00644"></a>00644 <span class="comment">   c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular</span>
<a name="l00645"></a>00645 <span class="comment">   c                     Schur matrix for H.</span>
<a name="l00646"></a>00646 <span class="comment">   c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors</span>
<a name="l00647"></a>00647 <span class="comment">   c                     of the upper Hessenberg matrix H. Only referenced by</span>
<a name="l00648"></a>00648 <span class="comment">   c                     dneupd if RVEC = .TRUE. See Remark 2 below.</span>
<a name="l00649"></a>00649 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l00650"></a>00650 <span class="comment">   c          </span>
<a name="l00651"></a>00651 <span class="comment">   c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)</span>
<a name="l00652"></a>00652 <span class="comment">   c          Distributed array to be used in the basic Arnoldi iteration</span>
<a name="l00653"></a>00653 <span class="comment">   c          for reverse communication.  The user should not use WORKD </span>
<a name="l00654"></a>00654 <span class="comment">   c          as temporary workspace during the iteration. Upon termination</span>
<a name="l00655"></a>00655 <span class="comment">   c          WORKD(1:N) contains B*RESID(1:N). If an invariant subspace</span>
<a name="l00656"></a>00656 <span class="comment">   c          associated with the converged Ritz values is desired, see remark</span>
<a name="l00657"></a>00657 <span class="comment">   c          2 below, subroutine dneupd uses this output.</span>
<a name="l00658"></a>00658 <span class="comment">   c          See Data Distribution Note below.  </span>
<a name="l00659"></a>00659 <span class="comment">   c</span>
<a name="l00660"></a>00660 <span class="comment">   c  WORKL   Double precision work array of length LWORKL.  (OUTPUT/WORKSPACE)</span>
<a name="l00661"></a>00661 <span class="comment">   c          Private (replicated) array on each PE or array allocated on</span>
<a name="l00662"></a>00662 <span class="comment">   c          the front end.  See Data Distribution Note below.</span>
<a name="l00663"></a>00663 <span class="comment">   c</span>
<a name="l00664"></a>00664 <span class="comment">   c  LWORKL  Integer.  (INPUT)</span>
<a name="l00665"></a>00665 <span class="comment">   c          LWORKL must be at least 3*NCV**2 + 6*NCV.</span>
<a name="l00666"></a>00666 <span class="comment">   c</span>
<a name="l00667"></a>00667 <span class="comment">   c  INFO    Integer.  (INPUT/OUTPUT)</span>
<a name="l00668"></a>00668 <span class="comment">   c          If INFO .EQ. 0, a randomly initial residual vector is used.</span>
<a name="l00669"></a>00669 <span class="comment">   c          If INFO .NE. 0, RESID contains the initial residual vector,</span>
<a name="l00670"></a>00670 <span class="comment">   c                          possibly from a previous run.</span>
<a name="l00671"></a>00671 <span class="comment">   c          Error flag on output.</span>
<a name="l00672"></a>00672 <span class="comment">   c          =  0: Normal exit.</span>
<a name="l00673"></a>00673 <span class="comment">   c          =  1: Maximum number of iterations taken.</span>
<a name="l00674"></a>00674 <span class="comment">   c                All possible eigenvalues of OP has been found. IPARAM(5)  </span>
<a name="l00675"></a>00675 <span class="comment">   c                returns the number of wanted converged Ritz values.</span>
<a name="l00676"></a>00676 <span class="comment">   c          =  2: No longer an informational error. Deprecated starting</span>
<a name="l00677"></a>00677 <span class="comment">   c                with release 2 of ARPACK.</span>
<a name="l00678"></a>00678 <span class="comment">   c          =  3: No shifts could be applied during a cycle of the </span>
<a name="l00679"></a>00679 <span class="comment">   c                Implicitly restarted Arnoldi iteration. One possibility </span>
<a name="l00680"></a>00680 <span class="comment">   c                is to increase the size of NCV relative to NEV. </span>
<a name="l00681"></a>00681 <span class="comment">   c                See remark 4 below.</span>
<a name="l00682"></a>00682 <span class="comment">   c          = -1: N must be positive.</span>
<a name="l00683"></a>00683 <span class="comment">   c          = -2: NEV must be positive.</span>
<a name="l00684"></a>00684 <span class="comment">   c          = -3: NCV-NEV &gt;= 2 and less than or equal to N.</span>
<a name="l00685"></a>00685 <span class="comment">   c          = -4: The maximum number of Arnoldi update iteration </span>
<a name="l00686"></a>00686 <span class="comment">   c                must be greater than zero.</span>
<a name="l00687"></a>00687 <span class="comment">   c          = -5: WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LR&#39;, &#39;SR&#39;, &#39;LI&#39;, &#39;SI&#39;</span>
<a name="l00688"></a>00688 <span class="comment">   c          = -6: BMAT must be one of &#39;I&#39; or &#39;G&#39;.</span>
<a name="l00689"></a>00689 <span class="comment">   c          = -7: Length of private work array is not sufficient.</span>
<a name="l00690"></a>00690 <span class="comment">   c          = -8: Error return from LAPACK eigenvalue calculation;</span>
<a name="l00691"></a>00691 <span class="comment">   c          = -9: Starting vector is zero.</span>
<a name="l00692"></a>00692 <span class="comment">   c          = -10: IPARAM(7) must be 1,2,3,4.</span>
<a name="l00693"></a>00693 <span class="comment">   c          = -11: IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatable.</span>
<a name="l00694"></a>00694 <span class="comment">   c          = -12: IPARAM(1) must be equal to 0 or 1.</span>
<a name="l00695"></a>00695 <span class="comment">   c          = -9999: Could not build an Arnoldi factorization.</span>
<a name="l00696"></a>00696 <span class="comment">   c                   IPARAM(5) returns the size of the current Arnoldi</span>
<a name="l00697"></a>00697 <span class="comment">   c                   factorization.</span>
<a name="l00698"></a>00698 <span class="comment">   c</span>
<a name="l00699"></a>00699 <span class="comment">   c\Remarks</span>
<a name="l00700"></a>00700 <span class="comment">   c  1. The computed Ritz values are approximate eigenvalues of OP. The</span>
<a name="l00701"></a>00701 <span class="comment">   c     selection of WHICH should be made with this in mind when</span>
<a name="l00702"></a>00702 <span class="comment">   c     Mode = 3 and 4.  After convergence, approximate eigenvalues of the</span>
<a name="l00703"></a>00703 <span class="comment">   c     original problem may be obtained with the ARPACK subroutine dneupd.</span>
<a name="l00704"></a>00704 <span class="comment">   c</span>
<a name="l00705"></a>00705 <span class="comment">   c  2. If a basis for the invariant subspace corresponding to the converged Ritz </span>
<a name="l00706"></a>00706 <span class="comment">   c     values is needed, the user must call dneupd immediately following </span>
<a name="l00707"></a>00707 <span class="comment">   c     completion of dnaupd. This is new starting with release 2 of ARPACK.</span>
<a name="l00708"></a>00708 <span class="comment">   c</span>
<a name="l00709"></a>00709 <span class="comment">   c  3. If M can be factored into a Cholesky factorization M = LL`</span>
<a name="l00710"></a>00710 <span class="comment">   c     then Mode = 2 should not be selected.  Instead one should use</span>
<a name="l00711"></a>00711 <span class="comment">   c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular </span>
<a name="l00712"></a>00712 <span class="comment">   c     linear systems should be solved with L and L` rather</span>
<a name="l00713"></a>00713 <span class="comment">   c     than computing inverses.  After convergence, an approximate</span>
<a name="l00714"></a>00714 <span class="comment">   c     eigenvector z of the original problem is recovered by solving</span>
<a name="l00715"></a>00715 <span class="comment">   c     L`z = x  where x is a Ritz vector of OP.</span>
<a name="l00716"></a>00716 <span class="comment">   c</span>
<a name="l00717"></a>00717 <span class="comment">   c  4. At present there is no a-priori analysis to guide the selection</span>
<a name="l00718"></a>00718 <span class="comment">   c     of NCV relative to NEV.  The only formal requrement is that NCV &gt; NEV + 2.</span>
<a name="l00719"></a>00719 <span class="comment">   c     However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of</span>
<a name="l00720"></a>00720 <span class="comment">   c     the same type are to be solved, one should experiment with increasing</span>
<a name="l00721"></a>00721 <span class="comment">   c     NCV while keeping NEV fixed for a given test problem.  This will </span>
<a name="l00722"></a>00722 <span class="comment">   c     usually decrease the required number of OP*x operations but it</span>
<a name="l00723"></a>00723 <span class="comment">   c     also increases the work and storage required to maintain the orthogonal</span>
<a name="l00724"></a>00724 <span class="comment">   c     basis vectors.  The optimal &quot;cross-over&quot; with respect to CPU time</span>
<a name="l00725"></a>00725 <span class="comment">   c     is problem dependent and must be determined empirically. </span>
<a name="l00726"></a>00726 <span class="comment">   c     See Chapter 8 of Reference 2 for further information.</span>
<a name="l00727"></a>00727 <span class="comment">   c</span>
<a name="l00728"></a>00728 <span class="comment">   c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the </span>
<a name="l00729"></a>00729 <span class="comment">   c     NP = IPARAM(8) real and imaginary parts of the shifts in locations </span>
<a name="l00730"></a>00730 <span class="comment">   c         real part                  imaginary part</span>
<a name="l00731"></a>00731 <span class="comment">   c         -----------------------    --------------</span>
<a name="l00732"></a>00732 <span class="comment">   c     1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)</span>
<a name="l00733"></a>00733 <span class="comment">   c     2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)</span>
<a name="l00734"></a>00734 <span class="comment">   c                        .                          .</span>
<a name="l00735"></a>00735 <span class="comment">   c                        .                          .</span>
<a name="l00736"></a>00736 <span class="comment">   c                        .                          .</span>
<a name="l00737"></a>00737 <span class="comment">   c     NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).</span>
<a name="l00738"></a>00738 <span class="comment">   c</span>
<a name="l00739"></a>00739 <span class="comment">   c     Only complex conjugate pairs of shifts may be applied and the pairs </span>
<a name="l00740"></a>00740 <span class="comment">   c     must be placed in consecutive locations. The real part of the </span>
<a name="l00741"></a>00741 <span class="comment">   c     eigenvalues of the current upper Hessenberg matrix are located in </span>
<a name="l00742"></a>00742 <span class="comment">   c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part </span>
<a name="l00743"></a>00743 <span class="comment">   c     in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered</span>
<a name="l00744"></a>00744 <span class="comment">   c     according to the order defined by WHICH. The complex conjugate</span>
<a name="l00745"></a>00745 <span class="comment">   c     pairs are kept together and the associated Ritz estimates are located in</span>
<a name="l00746"></a>00746 <span class="comment">   c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).</span>
<a name="l00747"></a>00747 <span class="comment">   c</span>
<a name="l00748"></a>00748 <span class="comment">   c-----------------------------------------------------------------------</span>
<a name="l00749"></a>00749 <span class="comment">   c</span>
<a name="l00750"></a>00750 <span class="comment">   c\Data Distribution Note: </span>
<a name="l00751"></a>00751 <span class="comment">   c</span>
<a name="l00752"></a>00752 <span class="comment">   c  Fortran-D syntax:</span>
<a name="l00753"></a>00753 <span class="comment">   c  ================</span>
<a name="l00754"></a>00754 <span class="comment">   c  Double precision resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)</span>
<a name="l00755"></a>00755 <span class="comment">   c  decompose  d1(n), d2(n,ncv)</span>
<a name="l00756"></a>00756 <span class="comment">   c  align      resid(i) with d1(i)</span>
<a name="l00757"></a>00757 <span class="comment">   c  align      v(i,j)   with d2(i,j)</span>
<a name="l00758"></a>00758 <span class="comment">   c  align      workd(i) with d1(i)     range (1:n)</span>
<a name="l00759"></a>00759 <span class="comment">   c  align      workd(i) with d1(i-n)   range (n+1:2*n)</span>
<a name="l00760"></a>00760 <span class="comment">   c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)</span>
<a name="l00761"></a>00761 <span class="comment">   c  distribute d1(block), d2(block,:)</span>
<a name="l00762"></a>00762 <span class="comment">   c  replicated workl(lworkl)</span>
<a name="l00763"></a>00763 <span class="comment">   c</span>
<a name="l00764"></a>00764 <span class="comment">   c  Cray MPP syntax:</span>
<a name="l00765"></a>00765 <span class="comment">   c  ===============</span>
<a name="l00766"></a>00766 <span class="comment">   c  Double precision  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)</span>
<a name="l00767"></a>00767 <span class="comment">   c  shared     resid(block), v(block,:), workd(block,:)</span>
<a name="l00768"></a>00768 <span class="comment">   c  replicated workl(lworkl)</span>
<a name="l00769"></a>00769 <span class="comment">   c  </span>
<a name="l00770"></a>00770 <span class="comment">   c  CM2/CM5 syntax:</span>
<a name="l00771"></a>00771 <span class="comment">   c  ==============</span>
<a name="l00772"></a>00772 <span class="comment">   c  </span>
<a name="l00773"></a>00773 <span class="comment">   c-----------------------------------------------------------------------</span>
<a name="l00774"></a>00774 <span class="comment">   c</span>
<a name="l00775"></a>00775 <span class="comment">   c     include   &#39;ex-nonsym.doc&#39;</span>
<a name="l00776"></a>00776 <span class="comment">   c</span>
<a name="l00777"></a>00777 <span class="comment">   c-----------------------------------------------------------------------</span>
<a name="l00778"></a>00778 <span class="comment">   c</span>
<a name="l00779"></a>00779 <span class="comment">   c\BeginLib</span>
<a name="l00780"></a>00780 <span class="comment">   c</span>
<a name="l00781"></a>00781 <span class="comment">   c\Local variables:</span>
<a name="l00782"></a>00782 <span class="comment">   c     xxxxxx  real</span>
<a name="l00783"></a>00783 <span class="comment">   c</span>
<a name="l00784"></a>00784 <span class="comment">   c\References:</span>
<a name="l00785"></a>00785 <span class="comment">   c  1. D.C. Sorensen, &quot;Implicit Application of Polynomial Filters in</span>
<a name="l00786"></a>00786 <span class="comment">   c     a k-Step Arnoldi Method&quot;, SIAM J. Matr. Anal. Apps., 13 (1992),</span>
<a name="l00787"></a>00787 <span class="comment">   c     pp 357-385.</span>
<a name="l00788"></a>00788 <span class="comment">   c  2. R.B. Lehoucq, &quot;Analysis and Implementation of an Implicitly </span>
<a name="l00789"></a>00789 <span class="comment">   c     Restarted Arnoldi Iteration&quot;, Rice University Technical Report</span>
<a name="l00790"></a>00790 <span class="comment">   c     TR95-13, Department of Computational and Applied Mathematics.</span>
<a name="l00791"></a>00791 <span class="comment">   c  3. B.N. Parlett &amp; Y. Saad, &quot;Complex Shift and Invert Strategies for</span>
<a name="l00792"></a>00792 <span class="comment">   c     Real Matrices&quot;, Linear Algebra and its Applications, vol 88/89,</span>
<a name="l00793"></a>00793 <span class="comment">   c     pp 575-595, (1987).</span>
<a name="l00794"></a>00794 <span class="comment">   c</span>
<a name="l00795"></a>00795 <span class="comment">   c\Routines called:</span>
<a name="l00796"></a>00796 <span class="comment">   c     dnaup2  ARPACK routine that implements the Implicitly Restarted</span>
<a name="l00797"></a>00797 <span class="comment">   c             Arnoldi Iteration.</span>
<a name="l00798"></a>00798 <span class="comment">   c     ivout   ARPACK utility routine that prints integers.</span>
<a name="l00799"></a>00799 <span class="comment">   c     second  ARPACK utility routine for timing.</span>
<a name="l00800"></a>00800 <span class="comment">   c     dvout   ARPACK utility routine that prints vectors.</span>
<a name="l00801"></a>00801 <span class="comment">   c     dlamch  LAPACK routine that determines machine constants.</span>
<a name="l00802"></a>00802 <span class="comment">   c</span>
<a name="l00803"></a>00803 <span class="comment">   c\Author</span>
<a name="l00804"></a>00804 <span class="comment">   c     Danny Sorensen               Phuong Vu</span>
<a name="l00805"></a>00805 <span class="comment">   c     Richard Lehoucq              CRPC / Rice University</span>
<a name="l00806"></a>00806 <span class="comment">   c     Dept. of Computational &amp;     Houston, Texas</span>
<a name="l00807"></a>00807 <span class="comment">   c     Applied Mathematics</span>
<a name="l00808"></a>00808 <span class="comment">   c     Rice University           </span>
<a name="l00809"></a>00809 <span class="comment">   c     Houston, Texas            </span>
<a name="l00810"></a>00810 <span class="comment">   c </span>
<a name="l00811"></a>00811 <span class="comment">   c\Revision history:</span>
<a name="l00812"></a>00812 <span class="comment">   c     12/16/93: Version &#39;1.1&#39;</span>
<a name="l00813"></a>00813 <span class="comment">   c</span>
<a name="l00814"></a>00814 <span class="comment">   c\SCCS Information: @(#) </span>
<a name="l00815"></a>00815 <span class="comment">   c FILE: naupd.F   SID: 2.10   DATE OF SID: 08/23/02   RELEASE: 2</span>
<a name="l00816"></a>00816 <span class="comment">   c</span>
<a name="l00817"></a>00817 <span class="comment">   c\Remarks</span>
<a name="l00818"></a>00818 <span class="comment">   c</span>
<a name="l00819"></a>00819 <span class="comment">   c\EndLib</span>
<a name="l00820"></a>00820 <span class="comment">   c</span>
<a name="l00821"></a>00821 <span class="comment">   c-----------------------------------------------------------------------</span>
<a name="l00822"></a>00822 <span class="comment">   */</span>    
<a name="l00823"></a>00823   <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="_f_e_system_config_8h.html#a5bf86bf228b4805fd9efbe403518ecd5">FC_FUNC</a>(dnaupd, DNAUPD)(<span class="keywordtype">int</span> *ido, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae169dc7c559f7af8031a367ca498c4cb">bmat</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aea1409bb93d418b91433540cbb22abc5">n</a>, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab695fb9382c8413b077bbe8d62fce5b6">which</a>,
<a name="l00824"></a>00824                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab8e386cc2c858827a0fab5aa19c51221">nev</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#adfa450f6854e6cb79b651f5ea37cc0d7">tol</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae3bea2bcd8aee5cc2306f8b015fdc69f">resid</a>,
<a name="l00825"></a>00825                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a4ea189c81e56ea26da24f4595139e248">ncv</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ac29db3dbb9b137ecb580f1dfeead0a1c">V</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a3ed32aee215e804a153ab56f9f12de6e">ldv</a>,
<a name="l00826"></a>00826                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a76f18698bf6be53202825afcf7e7ab44">iparam</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a27062ce0b07ecfa619748b16454161ae">ipntr</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a87f692b4c346d37e7718f6856c201e52">workd</a>,
<a name="l00827"></a>00827                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a05417caea45e8644016c6995591bf8c1">workl</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a72c793afa6be02aafd463a92b794b2ff">lworkl</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab4bdba131592d57176f37f9670deec34">info</a>);
<a name="l00828"></a>00828   
<a name="l00829"></a>00829   <span class="comment">/*</span>
<a name="l00830"></a>00830 <span class="comment">   c\BeginDoc</span>
<a name="l00831"></a>00831 <span class="comment">   c</span>
<a name="l00832"></a>00832 <span class="comment">   c\Name: dneupd </span>
<a name="l00833"></a>00833 <span class="comment">   c</span>
<a name="l00834"></a>00834 <span class="comment">   c\Description: </span>
<a name="l00835"></a>00835 <span class="comment">   c</span>
<a name="l00836"></a>00836 <span class="comment">   c  This subroutine returns the converged approximations to eigenvalues</span>
<a name="l00837"></a>00837 <span class="comment">   c  of A*z = lambda*B*z and (optionally):</span>
<a name="l00838"></a>00838 <span class="comment">   c</span>
<a name="l00839"></a>00839 <span class="comment">   c      (1) The corresponding approximate eigenvectors;</span>
<a name="l00840"></a>00840 <span class="comment">   c</span>
<a name="l00841"></a>00841 <span class="comment">   c      (2) An orthonormal basis for the associated approximate</span>
<a name="l00842"></a>00842 <span class="comment">   c          invariant subspace;</span>
<a name="l00843"></a>00843 <span class="comment">   c</span>
<a name="l00844"></a>00844 <span class="comment">   c      (3) Both.</span>
<a name="l00845"></a>00845 <span class="comment">   c</span>
<a name="l00846"></a>00846 <span class="comment">   c  There is negligible additional cost to obtain eigenvectors.  An orthonormal</span>
<a name="l00847"></a>00847 <span class="comment">   c  basis is always computed.  There is an additional storage cost of n*nev</span>
<a name="l00848"></a>00848 <span class="comment">   c  if both are requested (in this case a separate array Z must be supplied).</span>
<a name="l00849"></a>00849 <span class="comment">   c</span>
<a name="l00850"></a>00850 <span class="comment">   c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z</span>
<a name="l00851"></a>00851 <span class="comment">   c  are derived from approximate eigenvalues and eigenvectors of</span>
<a name="l00852"></a>00852 <span class="comment">   c  of the linear operator OP prescribed by the MODE selection in the</span>
<a name="l00853"></a>00853 <span class="comment">   c  call to DNAUPD .  DNAUPD  must be called before this routine is called.</span>
<a name="l00854"></a>00854 <span class="comment">   c  These approximate eigenvalues and vectors are commonly called Ritz</span>
<a name="l00855"></a>00855 <span class="comment">   c  values and Ritz vectors respectively.  They are referred to as such</span>
<a name="l00856"></a>00856 <span class="comment">   c  in the comments that follow.  The computed orthonormal basis for the</span>
<a name="l00857"></a>00857 <span class="comment">   c  invariant subspace corresponding to these Ritz values is referred to as a</span>
<a name="l00858"></a>00858 <span class="comment">   c  Schur basis.</span>
<a name="l00859"></a>00859 <span class="comment">   c</span>
<a name="l00860"></a>00860 <span class="comment">   c  See documentation in the header of the subroutine DNAUPD  for </span>
<a name="l00861"></a>00861 <span class="comment">   c  definition of OP as well as other terms and the relation of computed</span>
<a name="l00862"></a>00862 <span class="comment">   c  Ritz values and Ritz vectors of OP with respect to the given problem</span>
<a name="l00863"></a>00863 <span class="comment">   c  A*z = lambda*B*z.  For a brief description, see definitions of </span>
<a name="l00864"></a>00864 <span class="comment">   c  IPARAM(7), MODE and WHICH in the documentation of DNAUPD .</span>
<a name="l00865"></a>00865 <span class="comment">   c</span>
<a name="l00866"></a>00866 <span class="comment">   c\Usage:</span>
<a name="l00867"></a>00867 <span class="comment">   c  call dneupd  </span>
<a name="l00868"></a>00868 <span class="comment">   c     ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT, </span>
<a name="l00869"></a>00869 <span class="comment">   c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, </span>
<a name="l00870"></a>00870 <span class="comment">   c       LWORKL, INFO )</span>
<a name="l00871"></a>00871 <span class="comment">   c</span>
<a name="l00872"></a>00872 <span class="comment">   c\Arguments:</span>
<a name="l00873"></a>00873 <span class="comment">   c  RVEC    LOGICAL  (INPUT) </span>
<a name="l00874"></a>00874 <span class="comment">   c          Specifies whether a basis for the invariant subspace corresponding </span>
<a name="l00875"></a>00875 <span class="comment">   c          to the converged Ritz value approximations for the eigenproblem </span>
<a name="l00876"></a>00876 <span class="comment">   c          A*z = lambda*B*z is computed.</span>
<a name="l00877"></a>00877 <span class="comment">   c</span>
<a name="l00878"></a>00878 <span class="comment">   c             RVEC = .FALSE.     Compute Ritz values only.</span>
<a name="l00879"></a>00879 <span class="comment">   c</span>
<a name="l00880"></a>00880 <span class="comment">   c             RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.</span>
<a name="l00881"></a>00881 <span class="comment">   c                                See Remarks below. </span>
<a name="l00882"></a>00882 <span class="comment">   c </span>
<a name="l00883"></a>00883 <span class="comment">   c  HOWMNY  Character*1  (INPUT) </span>
<a name="l00884"></a>00884 <span class="comment">   c          Specifies the form of the basis for the invariant subspace </span>
<a name="l00885"></a>00885 <span class="comment">   c          corresponding to the converged Ritz values that is to be computed.</span>
<a name="l00886"></a>00886 <span class="comment">   c</span>
<a name="l00887"></a>00887 <span class="comment">   c          = &#39;A&#39;: Compute NEV Ritz vectors; </span>
<a name="l00888"></a>00888 <span class="comment">   c          = &#39;P&#39;: Compute NEV Schur vectors;</span>
<a name="l00889"></a>00889 <span class="comment">   c          = &#39;S&#39;: compute some of the Ritz vectors, specified</span>
<a name="l00890"></a>00890 <span class="comment">   c                 by the logical array SELECT.</span>
<a name="l00891"></a>00891 <span class="comment">   c</span>
<a name="l00892"></a>00892 <span class="comment">   c  SELECT  Logical array of dimension NCV.  (INPUT)</span>
<a name="l00893"></a>00893 <span class="comment">   c          If HOWMNY = &#39;S&#39;, SELECT specifies the Ritz vectors to be</span>
<a name="l00894"></a>00894 <span class="comment">   c          computed. To select the Ritz vector corresponding to a</span>
<a name="l00895"></a>00895 <span class="comment">   c          Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE.. </span>
<a name="l00896"></a>00896 <span class="comment">   c          If HOWMNY = &#39;A&#39; or &#39;P&#39;, SELECT is used as internal workspace.</span>
<a name="l00897"></a>00897 <span class="comment">   c</span>
<a name="l00898"></a>00898 <span class="comment">   c  DR      Double precision  array of dimension NEV+1.  (OUTPUT)</span>
<a name="l00899"></a>00899 <span class="comment">   c          If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains </span>
<a name="l00900"></a>00900 <span class="comment">   c          the real part of the Ritz  approximations to the eigenvalues of </span>
<a name="l00901"></a>00901 <span class="comment">   c          A*z = lambda*B*z. </span>
<a name="l00902"></a>00902 <span class="comment">   c          If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:</span>
<a name="l00903"></a>00903 <span class="comment">   c          DR contains the real part of the Ritz values of OP computed by </span>
<a name="l00904"></a>00904 <span class="comment">   c          DNAUPD . A further computation must be performed by the user</span>
<a name="l00905"></a>00905 <span class="comment">   c          to transform the Ritz values computed for OP by DNAUPD  to those</span>
<a name="l00906"></a>00906 <span class="comment">   c          of the original system A*z = lambda*B*z. See remark 3 below.</span>
<a name="l00907"></a>00907 <span class="comment">   c</span>
<a name="l00908"></a>00908 <span class="comment">   c  DI      Double precision  array of dimension NEV+1.  (OUTPUT)</span>
<a name="l00909"></a>00909 <span class="comment">   c          On exit, DI contains the imaginary part of the Ritz value </span>
<a name="l00910"></a>00910 <span class="comment">   c          approximations to the eigenvalues of A*z = lambda*B*z associated</span>
<a name="l00911"></a>00911 <span class="comment">   c          with DR.</span>
<a name="l00912"></a>00912 <span class="comment">   c</span>
<a name="l00913"></a>00913 <span class="comment">   c          NOTE: When Ritz values are complex, they will come in complex </span>
<a name="l00914"></a>00914 <span class="comment">   c                conjugate pairs.  If eigenvectors are requested, the </span>
<a name="l00915"></a>00915 <span class="comment">   c                corresponding Ritz vectors will also come in conjugate </span>
<a name="l00916"></a>00916 <span class="comment">   c                pairs and the real and imaginary parts of these are </span>
<a name="l00917"></a>00917 <span class="comment">   c                represented in two consecutive columns of the array Z </span>
<a name="l00918"></a>00918 <span class="comment">   c                (see below).</span>
<a name="l00919"></a>00919 <span class="comment">   c</span>
<a name="l00920"></a>00920 <span class="comment">   c  Z       Double precision  N by NEV+1 array if RVEC = .TRUE. and HOWMNY = &#39;A&#39;. (OUTPUT)</span>
<a name="l00921"></a>00921 <span class="comment">   c          On exit, if RVEC = .TRUE. and HOWMNY = &#39;A&#39;, then the columns of </span>
<a name="l00922"></a>00922 <span class="comment">   c          Z represent approximate eigenvectors (Ritz vectors) corresponding </span>
<a name="l00923"></a>00923 <span class="comment">   c          to the NCONV=IPARAM(5) Ritz values for eigensystem </span>
<a name="l00924"></a>00924 <span class="comment">   c          A*z = lambda*B*z. </span>
<a name="l00925"></a>00925 <span class="comment">   c </span>
<a name="l00926"></a>00926 <span class="comment">   c          The complex Ritz vector associated with the Ritz value </span>
<a name="l00927"></a>00927 <span class="comment">   c          with positive imaginary part is stored in two consecutive </span>
<a name="l00928"></a>00928 <span class="comment">   c          columns.  The first column holds the real part of the Ritz </span>
<a name="l00929"></a>00929 <span class="comment">   c          vector and the second column holds the imaginary part.  The </span>
<a name="l00930"></a>00930 <span class="comment">   c          Ritz vector associated with the Ritz value with negative </span>
<a name="l00931"></a>00931 <span class="comment">   c          imaginary part is simply the complex conjugate of the Ritz vector </span>
<a name="l00932"></a>00932 <span class="comment">   c          associated with the positive imaginary part.</span>
<a name="l00933"></a>00933 <span class="comment">   c</span>
<a name="l00934"></a>00934 <span class="comment">   c          If  RVEC = .FALSE. or HOWMNY = &#39;P&#39;, then Z is not referenced.</span>
<a name="l00935"></a>00935 <span class="comment">   c</span>
<a name="l00936"></a>00936 <span class="comment">   c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,</span>
<a name="l00937"></a>00937 <span class="comment">   c          the array Z may be set equal to first NEV+1 columns of the Arnoldi</span>
<a name="l00938"></a>00938 <span class="comment">   c          basis array V computed by DNAUPD .  In this case the Arnoldi basis</span>
<a name="l00939"></a>00939 <span class="comment">   c          will be destroyed and overwritten with the eigenvector basis.</span>
<a name="l00940"></a>00940 <span class="comment">   c</span>
<a name="l00941"></a>00941 <span class="comment">   c  LDZ     Integer.  (INPUT)</span>
<a name="l00942"></a>00942 <span class="comment">   c          The leading dimension of the array Z.  If Ritz vectors are</span>
<a name="l00943"></a>00943 <span class="comment">   c          desired, then  LDZ &gt;= max( 1, N ).  In any case,  LDZ &gt;= 1.</span>
<a name="l00944"></a>00944 <span class="comment">   c</span>
<a name="l00945"></a>00945 <span class="comment">   c  SIGMAR  Double precision   (INPUT)</span>
<a name="l00946"></a>00946 <span class="comment">   c          If IPARAM(7) = 3 or 4, represents the real part of the shift. </span>
<a name="l00947"></a>00947 <span class="comment">   c          Not referenced if IPARAM(7) = 1 or 2.</span>
<a name="l00948"></a>00948 <span class="comment">   c</span>
<a name="l00949"></a>00949 <span class="comment">   c  SIGMAI  Double precision   (INPUT)</span>
<a name="l00950"></a>00950 <span class="comment">   c          If IPARAM(7) = 3 or 4, represents the imaginary part of the shift. </span>
<a name="l00951"></a>00951 <span class="comment">   c          Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.</span>
<a name="l00952"></a>00952 <span class="comment">   c</span>
<a name="l00953"></a>00953 <span class="comment">   c  WORKEV  Double precision  work array of dimension 3*NCV.  (WORKSPACE)</span>
<a name="l00954"></a>00954 <span class="comment">   c</span>
<a name="l00955"></a>00955 <span class="comment">   c  **** The remaining arguments MUST be the same as for the   ****</span>
<a name="l00956"></a>00956 <span class="comment">   c  **** call to DNAUPD  that was just completed.               ****</span>
<a name="l00957"></a>00957 <span class="comment">   c</span>
<a name="l00958"></a>00958 <span class="comment">   c  NOTE: The remaining arguments</span>
<a name="l00959"></a>00959 <span class="comment">   c</span>
<a name="l00960"></a>00960 <span class="comment">   c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,</span>
<a name="l00961"></a>00961 <span class="comment">   c           WORKD, WORKL, LWORKL, INFO</span>
<a name="l00962"></a>00962 <span class="comment">   c</span>
<a name="l00963"></a>00963 <span class="comment">   c         must be passed directly to DNEUPD  following the last call</span>
<a name="l00964"></a>00964 <span class="comment">   c         to DNAUPD .  These arguments MUST NOT BE MODIFIED between</span>
<a name="l00965"></a>00965 <span class="comment">   c         the the last call to DNAUPD  and the call to DNEUPD .</span>
<a name="l00966"></a>00966 <span class="comment">   c</span>
<a name="l00967"></a>00967 <span class="comment">   c  Three of these parameters (V, WORKL, INFO) are also output parameters:</span>
<a name="l00968"></a>00968 <span class="comment">   c</span>
<a name="l00969"></a>00969 <span class="comment">   c  V       Double precision  N by NCV array.  (INPUT/OUTPUT)</span>
<a name="l00970"></a>00970 <span class="comment">   c</span>
<a name="l00971"></a>00971 <span class="comment">   c          Upon INPUT: the NCV columns of V contain the Arnoldi basis</span>
<a name="l00972"></a>00972 <span class="comment">   c                      vectors for OP as constructed by DNAUPD  .</span>
<a name="l00973"></a>00973 <span class="comment">   c</span>
<a name="l00974"></a>00974 <span class="comment">   c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns</span>
<a name="l00975"></a>00975 <span class="comment">   c                       contain approximate Schur vectors that span the</span>
<a name="l00976"></a>00976 <span class="comment">   c                       desired invariant subspace.  See Remark 2 below.</span>
<a name="l00977"></a>00977 <span class="comment">   c</span>
<a name="l00978"></a>00978 <span class="comment">   c          NOTE: If the array Z has been set equal to first NEV+1 columns</span>
<a name="l00979"></a>00979 <span class="comment">   c          of the array V and RVEC=.TRUE. and HOWMNY= &#39;A&#39;, then the</span>
<a name="l00980"></a>00980 <span class="comment">   c          Arnoldi basis held by V has been overwritten by the desired</span>
<a name="l00981"></a>00981 <span class="comment">   c          Ritz vectors.  If a separate array Z has been passed then</span>
<a name="l00982"></a>00982 <span class="comment">   c          the first NCONV=IPARAM(5) columns of V will contain approximate</span>
<a name="l00983"></a>00983 <span class="comment">   c          Schur vectors that span the desired invariant subspace.</span>
<a name="l00984"></a>00984 <span class="comment">   c</span>
<a name="l00985"></a>00985 <span class="comment">   c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)</span>
<a name="l00986"></a>00986 <span class="comment">   c          WORKL(1:ncv*ncv+3*ncv) contains information obtained in</span>
<a name="l00987"></a>00987 <span class="comment">   c          dnaupd .  They are not changed by dneupd .</span>
<a name="l00988"></a>00988 <span class="comment">   c          WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the</span>
<a name="l00989"></a>00989 <span class="comment">   c          real and imaginary part of the untransformed Ritz values,</span>
<a name="l00990"></a>00990 <span class="comment">   c          the upper quasi-triangular matrix for H, and the</span>
<a name="l00991"></a>00991 <span class="comment">   c          associated matrix representation of the invariant subspace for H.</span>
<a name="l00992"></a>00992 <span class="comment">   c</span>
<a name="l00993"></a>00993 <span class="comment">   c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses</span>
<a name="l00994"></a>00994 <span class="comment">   c          of the above information computed by dneupd .</span>
<a name="l00995"></a>00995 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l00996"></a>00996 <span class="comment">   c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the</span>
<a name="l00997"></a>00997 <span class="comment">   c                     original system.</span>
<a name="l00998"></a>00998 <span class="comment">   c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of</span>
<a name="l00999"></a>00999 <span class="comment">   c                     the original system.</span>
<a name="l01000"></a>01000 <span class="comment">   c          IPNTR(11): pointer to the NCV corresponding error bounds.</span>
<a name="l01001"></a>01001 <span class="comment">   c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular</span>
<a name="l01002"></a>01002 <span class="comment">   c                     Schur matrix for H.</span>
<a name="l01003"></a>01003 <span class="comment">   c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors</span>
<a name="l01004"></a>01004 <span class="comment">   c                     of the upper Hessenberg matrix H. Only referenced by</span>
<a name="l01005"></a>01005 <span class="comment">   c                     dneupd  if RVEC = .TRUE. See Remark 2 below.</span>
<a name="l01006"></a>01006 <span class="comment">   c          -------------------------------------------------------------</span>
<a name="l01007"></a>01007 <span class="comment">   c</span>
<a name="l01008"></a>01008 <span class="comment">   c  INFO    Integer.  (OUTPUT)</span>
<a name="l01009"></a>01009 <span class="comment">   c          Error flag on output.</span>
<a name="l01010"></a>01010 <span class="comment">   c</span>
<a name="l01011"></a>01011 <span class="comment">   c          =  0: Normal exit.</span>
<a name="l01012"></a>01012 <span class="comment">   c</span>
<a name="l01013"></a>01013 <span class="comment">   c          =  1: The Schur form computed by LAPACK routine dlahqr </span>
<a name="l01014"></a>01014 <span class="comment">   c                could not be reordered by LAPACK routine dtrsen .</span>
<a name="l01015"></a>01015 <span class="comment">   c                Re-enter subroutine dneupd  with IPARAM(5)=NCV and </span>
<a name="l01016"></a>01016 <span class="comment">   c                increase the size of the arrays DR and DI to have </span>
<a name="l01017"></a>01017 <span class="comment">   c                dimension at least dimension NCV and allocate at least NCV </span>
<a name="l01018"></a>01018 <span class="comment">   c                columns for Z. NOTE: Not necessary if Z and V share </span>
<a name="l01019"></a>01019 <span class="comment">   c                the same space. Please notify the authors if this error</span>
<a name="l01020"></a>01020 <span class="comment">   c                occurs.</span>
<a name="l01021"></a>01021 <span class="comment">   c</span>
<a name="l01022"></a>01022 <span class="comment">   c          = -1: N must be positive.</span>
<a name="l01023"></a>01023 <span class="comment">   c          = -2: NEV must be positive.</span>
<a name="l01024"></a>01024 <span class="comment">   c          = -3: NCV-NEV &gt;= 2 and less than or equal to N.</span>
<a name="l01025"></a>01025 <span class="comment">   c          = -5: WHICH must be one of &#39;LM&#39;, &#39;SM&#39;, &#39;LR&#39;, &#39;SR&#39;, &#39;LI&#39;, &#39;SI&#39;</span>
<a name="l01026"></a>01026 <span class="comment">   c          = -6: BMAT must be one of &#39;I&#39; or &#39;G&#39;.</span>
<a name="l01027"></a>01027 <span class="comment">   c          = -7: Length of private work WORKL array is not sufficient.</span>
<a name="l01028"></a>01028 <span class="comment">   c          = -8: Error return from calculation of a real Schur form.</span>
<a name="l01029"></a>01029 <span class="comment">   c                Informational error from LAPACK routine dlahqr .</span>
<a name="l01030"></a>01030 <span class="comment">   c          = -9: Error return from calculation of eigenvectors.</span>
<a name="l01031"></a>01031 <span class="comment">   c                Informational error from LAPACK routine dtrevc .</span>
<a name="l01032"></a>01032 <span class="comment">   c          = -10: IPARAM(7) must be 1,2,3,4.</span>
<a name="l01033"></a>01033 <span class="comment">   c          = -11: IPARAM(7) = 1 and BMAT = &#39;G&#39; are incompatible.</span>
<a name="l01034"></a>01034 <span class="comment">   c          = -12: HOWMNY = &#39;S&#39; not yet implemented</span>
<a name="l01035"></a>01035 <span class="comment">   c          = -13: HOWMNY must be one of &#39;A&#39; or &#39;P&#39; if RVEC = .true.</span>
<a name="l01036"></a>01036 <span class="comment">   c          = -14: DNAUPD  did not find any eigenvalues to sufficient</span>
<a name="l01037"></a>01037 <span class="comment">   c                 accuracy.</span>
<a name="l01038"></a>01038 <span class="comment">   c          = -15: DNEUPD got a different count of the number of converged</span>
<a name="l01039"></a>01039 <span class="comment">   c                 Ritz values than DNAUPD got.  This indicates the user</span>
<a name="l01040"></a>01040 <span class="comment">   c                 probably made an error in passing data from DNAUPD to</span>
<a name="l01041"></a>01041 <span class="comment">   c                 DNEUPD or that the data was modified before entering</span>
<a name="l01042"></a>01042 <span class="comment">   c                 DNEUPD</span>
<a name="l01043"></a>01043 <span class="comment">   c</span>
<a name="l01044"></a>01044 <span class="comment">   c\BeginLib</span>
<a name="l01045"></a>01045 <span class="comment">   c</span>
<a name="l01046"></a>01046 <span class="comment">   c\References:</span>
<a name="l01047"></a>01047 <span class="comment">   c  1. D.C. Sorensen, &quot;Implicit Application of Polynomial Filters in</span>
<a name="l01048"></a>01048 <span class="comment">   c     a k-Step Arnoldi Method&quot;, SIAM J. Matr. Anal. Apps., 13 (1992),</span>
<a name="l01049"></a>01049 <span class="comment">   c     pp 357-385.</span>
<a name="l01050"></a>01050 <span class="comment">   c  2. R.B. Lehoucq, &quot;Analysis and Implementation of an Implicitly </span>
<a name="l01051"></a>01051 <span class="comment">   c     Restarted Arnoldi Iteration&quot;, Rice University Technical Report</span>
<a name="l01052"></a>01052 <span class="comment">   c     TR95-13, Department of Computational and Applied Mathematics.</span>
<a name="l01053"></a>01053 <span class="comment">   c  3. B.N. Parlett &amp; Y. Saad, &quot;Complex Shift and Invert Strategies for</span>
<a name="l01054"></a>01054 <span class="comment">   c     Real Matrices&quot;, Linear Algebra and its Applications, vol 88/89,</span>
<a name="l01055"></a>01055 <span class="comment">   c     pp 575-595, (1987).</span>
<a name="l01056"></a>01056 <span class="comment">   c</span>
<a name="l01057"></a>01057 <span class="comment">   c\Routines called:</span>
<a name="l01058"></a>01058 <span class="comment">   c     ivout   ARPACK utility routine that prints integers.</span>
<a name="l01059"></a>01059 <span class="comment">   c     dmout    ARPACK utility routine that prints matrices</span>
<a name="l01060"></a>01060 <span class="comment">   c     dvout    ARPACK utility routine that prints vectors.</span>
<a name="l01061"></a>01061 <span class="comment">   c     dgeqr2   LAPACK routine that computes the QR factorization of </span>
<a name="l01062"></a>01062 <span class="comment">   c             a matrix.</span>
<a name="l01063"></a>01063 <span class="comment">   c     dlacpy   LAPACK matrix copy routine.</span>
<a name="l01064"></a>01064 <span class="comment">   c     dlahqr   LAPACK routine to compute the real Schur form of an</span>
<a name="l01065"></a>01065 <span class="comment">   c             upper Hessenberg matrix.</span>
<a name="l01066"></a>01066 <span class="comment">   c     dlamch   LAPACK routine that determines machine constants.</span>
<a name="l01067"></a>01067 <span class="comment">   c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.</span>
<a name="l01068"></a>01068 <span class="comment">   c     dlaset   LAPACK matrix initialization routine.</span>
<a name="l01069"></a>01069 <span class="comment">   c     dorm2r   LAPACK routine that applies an orthogonal matrix in </span>
<a name="l01070"></a>01070 <span class="comment">   c             factored form.</span>
<a name="l01071"></a>01071 <span class="comment">   c     dtrevc   LAPACK routine to compute the eigenvectors of a matrix</span>
<a name="l01072"></a>01072 <span class="comment">   c             in upper quasi-triangular form.</span>
<a name="l01073"></a>01073 <span class="comment">   c     dtrsen   LAPACK routine that re-orders the Schur form.</span>
<a name="l01074"></a>01074 <span class="comment">   c     dtrmm    Level 3 BLAS matrix times an upper triangular matrix.</span>
<a name="l01075"></a>01075 <span class="comment">   c     dger     Level 2 BLAS rank one update to a matrix.</span>
<a name="l01076"></a>01076 <span class="comment">   c     dcopy    Level 1 BLAS that copies one vector to another .</span>
<a name="l01077"></a>01077 <span class="comment">   c     ddot     Level 1 BLAS that computes the scalar product of two vectors.</span>
<a name="l01078"></a>01078 <span class="comment">   c     dnrm2    Level 1 BLAS that computes the norm of a vector.</span>
<a name="l01079"></a>01079 <span class="comment">   c     dscal    Level 1 BLAS that scales a vector.</span>
<a name="l01080"></a>01080 <span class="comment">   c</span>
<a name="l01081"></a>01081 <span class="comment">   c\Remarks</span>
<a name="l01082"></a>01082 <span class="comment">   c</span>
<a name="l01083"></a>01083 <span class="comment">   c  1. Currently only HOWMNY = &#39;A&#39; and &#39;P&#39; are implemented.</span>
<a name="l01084"></a>01084 <span class="comment">   c</span>
<a name="l01085"></a>01085 <span class="comment">   c     Let trans(X) denote the transpose of X.</span>
<a name="l01086"></a>01086 <span class="comment">   c</span>
<a name="l01087"></a>01087 <span class="comment">   c  2. Schur vectors are an orthogonal representation for the basis of</span>
<a name="l01088"></a>01088 <span class="comment">   c     Ritz vectors. Thus, their numerical properties are often superior.</span>
<a name="l01089"></a>01089 <span class="comment">   c     If RVEC = .TRUE. then the relationship</span>
<a name="l01090"></a>01090 <span class="comment">   c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and</span>
<a name="l01091"></a>01091 <span class="comment">   c     trans(V(:,1:IPARAM(5))) * V(:,1:IPARAM(5)) = I are approximately </span>
<a name="l01092"></a>01092 <span class="comment">   c     satisfied. Here T is the leading submatrix of order IPARAM(5) of the </span>
<a name="l01093"></a>01093 <span class="comment">   c     real upper quasi-triangular matrix stored workl(ipntr(12)). That is,</span>
<a name="l01094"></a>01094 <span class="comment">   c     T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; </span>
<a name="l01095"></a>01095 <span class="comment">   c     each 2-by-2 diagonal block has its diagonal elements equal and its</span>
<a name="l01096"></a>01096 <span class="comment">   c     off-diagonal elements of opposite sign.  Corresponding to each 2-by-2</span>
<a name="l01097"></a>01097 <span class="comment">   c     diagonal block is a complex conjugate pair of Ritz values. The real</span>
<a name="l01098"></a>01098 <span class="comment">   c     Ritz values are stored on the diagonal of T.</span>
<a name="l01099"></a>01099 <span class="comment">   c</span>
<a name="l01100"></a>01100 <span class="comment">   c  3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must</span>
<a name="l01101"></a>01101 <span class="comment">   c     form the IPARAM(5) Rayleigh quotients in order to transform the Ritz</span>
<a name="l01102"></a>01102 <span class="comment">   c     values computed by DNAUPD  for OP to those of A*z = lambda*B*z. </span>
<a name="l01103"></a>01103 <span class="comment">   c     Set RVEC = .true. and HOWMNY = &#39;A&#39;, and</span>
<a name="l01104"></a>01104 <span class="comment">   c     compute </span>
<a name="l01105"></a>01105 <span class="comment">   c           trans(Z(:,I)) * A * Z(:,I) if DI(I) = 0.</span>
<a name="l01106"></a>01106 <span class="comment">   c     If DI(I) is not equal to zero and DI(I+1) = - D(I), </span>
<a name="l01107"></a>01107 <span class="comment">   c     then the desired real and imaginary parts of the Ritz value are</span>
<a name="l01108"></a>01108 <span class="comment">   c           trans(Z(:,I)) * A * Z(:,I) +  trans(Z(:,I+1)) * A * Z(:,I+1),</span>
<a name="l01109"></a>01109 <span class="comment">   c           trans(Z(:,I)) * A * Z(:,I+1) -  trans(Z(:,I+1)) * A * Z(:,I), </span>
<a name="l01110"></a>01110 <span class="comment">   c     respectively.</span>
<a name="l01111"></a>01111 <span class="comment">   c     Another possibility is to set RVEC = .true. and HOWMNY = &#39;P&#39; and</span>
<a name="l01112"></a>01112 <span class="comment">   c     compute trans(V(:,1:IPARAM(5))) * A * V(:,1:IPARAM(5)) and then an upper</span>
<a name="l01113"></a>01113 <span class="comment">   c     quasi-triangular matrix of order IPARAM(5) is computed. See remark</span>
<a name="l01114"></a>01114 <span class="comment">   c     2 above.</span>
<a name="l01115"></a>01115 <span class="comment">   c</span>
<a name="l01116"></a>01116 <span class="comment">   c\Authors</span>
<a name="l01117"></a>01117 <span class="comment">   c     Danny Sorensen               Phuong Vu</span>
<a name="l01118"></a>01118 <span class="comment">   c     Richard Lehoucq              CRPC / Rice University </span>
<a name="l01119"></a>01119 <span class="comment">   c     Chao Yang                    Houston, Texas</span>
<a name="l01120"></a>01120 <span class="comment">   c     Dept. of Computational &amp;</span>
<a name="l01121"></a>01121 <span class="comment">   c     Applied Mathematics          </span>
<a name="l01122"></a>01122 <span class="comment">   c     Rice University           </span>
<a name="l01123"></a>01123 <span class="comment">   c     Houston, Texas            </span>
<a name="l01124"></a>01124 <span class="comment">   c </span>
<a name="l01125"></a>01125 <span class="comment">   c\SCCS Information: @(#) </span>
<a name="l01126"></a>01126 <span class="comment">   c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2 </span>
<a name="l01127"></a>01127 <span class="comment">   c</span>
<a name="l01128"></a>01128 <span class="comment">   c\EndLib</span>
<a name="l01129"></a>01129 <span class="comment">   c</span>
<a name="l01130"></a>01130 <span class="comment">   c-----------------------------------------------------------------------</span>
<a name="l01131"></a>01131 <span class="comment">   */</span>
<a name="l01132"></a>01132   
<a name="l01133"></a><a class="code" href="_arpack_eigen_solver_8h.html#a38d7f6c63d08d4c68dd370ea035dec30">01133</a>   <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="_f_e_system_config_8h.html#a5bf86bf228b4805fd9efbe403518ecd5">FC_FUNC</a>(dneupd, DNEUPD)(<span class="keywordtype">int</span> *rvec, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a6a6266aa9975d725fd12991126f47240">HowMny</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aaa210a43690eb16c620f77ad3d85520e">select</a>,
<a name="l01134"></a>01134                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a6e845b7953f685740d7ffaa673e51f14">dr</a>,<span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a584deb52a83d9f61205006a43f9546e5">di</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a540cfc30f381a8ed8eecd97ae19e1f48">Z</a>,
<a name="l01135"></a>01135                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aa669ebf7f44e1a79551bcf7c4ef1dfc2">ldz</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a946cf9c72cd88f3757933ac6cbb6604e">sigmar</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a0ae28ba59ed9cf867f0663c83503b4c8">sigmai</a>, 
<a name="l01136"></a>01136                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a38d7f6c63d08d4c68dd370ea035dec30">workev</a>, <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae169dc7c559f7af8031a367ca498c4cb">bmat</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#aea1409bb93d418b91433540cbb22abc5">n</a>,
<a name="l01137"></a>01137                                       <span class="keywordtype">char</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab695fb9382c8413b077bbe8d62fce5b6">which</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab8e386cc2c858827a0fab5aa19c51221">nev</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#adfa450f6854e6cb79b651f5ea37cc0d7">tol</a>, 
<a name="l01138"></a>01138                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ae3bea2bcd8aee5cc2306f8b015fdc69f">resid</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a4ea189c81e56ea26da24f4595139e248">ncv</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ac29db3dbb9b137ecb580f1dfeead0a1c">V</a>, 
<a name="l01139"></a>01139                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a3ed32aee215e804a153ab56f9f12de6e">ldv</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a76f18698bf6be53202825afcf7e7ab44">iparam</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a27062ce0b07ecfa619748b16454161ae">ipntr</a>, 
<a name="l01140"></a>01140                                       <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a87f692b4c346d37e7718f6856c201e52">workd</a>, <span class="keywordtype">double</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a05417caea45e8644016c6995591bf8c1">workl</a>, <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#a72c793afa6be02aafd463a92b794b2ff">lworkl</a>, 
<a name="l01141"></a>01141                                       <span class="keywordtype">int</span> *<a class="code" href="_arpack_eigen_solver_8h.html#ab4bdba131592d57176f37f9670deec34">info</a>);
<a name="l01142"></a>01142   
<a name="l01143"></a>01143 }
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 
<a name="l01146"></a>01146 <span class="comment">// Forward Declerations</span>
<a name="l01147"></a>01147 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt; <span class="keyword">class </span>NumericVector;
<a name="l01148"></a>01148 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt; <span class="keyword">class </span>SparseMatrix;
<a name="l01149"></a>01149 
<a name="l01150"></a>01150 
<a name="l01151"></a>01151 <span class="preprocessor">#ifndef ARPACK_EIGEN_SOLVER_ENUM_ID</span>
<a name="l01152"></a><a class="code" href="_arpack_eigen_solver_8h.html#a0871457f3190c0e4bd33f0f19669dd7a">01152</a> <span class="preprocessor"></span><span class="preprocessor">#define ARPACK_EIGEN_SOLVER_ENUM_ID 7</span>
<a name="l01153"></a>01153 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01154"></a>01154 <span class="preprocessor"></span><span class="preprocessor">#error</span>
<a name="l01155"></a>01155 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span>
<a name="l01157"></a>01157 <span class="preprocessor">#ifndef ARPACK_EIGEN_SOLVER_ENUM_NAME</span>
<a name="l01158"></a><a class="code" href="_arpack_eigen_solver_8h.html#a29ca37fa59f15ea29bcee89dc42bf0aa">01158</a> <span class="preprocessor"></span><span class="preprocessor">#define ARPACK_EIGEN_SOLVER_ENUM_NAME &quot;ARPACK_EIGEN_SOLVER&quot;</span>
<a name="l01159"></a>01159 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span><span class="preprocessor">#error</span>
<a name="l01161"></a>01161 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span>
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 <span class="keyword">namespace </span>Solver
<a name="l01167"></a>01167 {
<a name="l01168"></a>01168   
<a name="l01169"></a>01169   <a class="code" href="namespace_solver.html#a05548d5a57e7b9cd05ae1d142f0d9c2c">DeclareEnumName</a>(ARPACK_EIGEN_SOLVER, Solver::EigenSolverKindEnum,
<a name="l01170"></a>01170                   <a class="code" href="_arpack_eigen_solver_8h.html#a0871457f3190c0e4bd33f0f19669dd7a">ARPACK_EIGEN_SOLVER_ENUM_ID</a>,
<a name="l01171"></a>01171                   <a class="code" href="_arpack_eigen_solver_8h.html#a29ca37fa59f15ea29bcee89dc42bf0aa">ARPACK_EIGEN_SOLVER_ENUM_NAME</a>);
<a name="l01172"></a>01172   
<a name="l01173"></a>01173   <span class="comment"></span>
<a name="l01174"></a>01174 <span class="comment">  /// this class provides an interface to a solver for the solution of </span>
<a name="l01175"></a>01175 <span class="comment">  /// eigensystem. This inherits from the FESystemSolverBase</span>
<a name="l01176"></a>01176 <span class="comment">  /// class. It takes a pointer to the analysis driver object that owns </span>
<a name="l01177"></a>01177 <span class="comment">  /// an instantiation of this class</span>
<a name="l01178"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html">01178</a> <span class="comment"></span>  <span class="keyword">class </span><a class="code" href="class_solver_1_1_arpack_eigen_solver.html">ArpackEigenSolver</a> : <span class="keyword">public</span> <a class="code" href="class_solver_1_1_eigen_solver_base.html">EigenSolverBase</a>
<a name="l01179"></a>01179     {
<a name="l01180"></a>01180     <span class="keyword">public</span>:
<a name="l01181"></a>01181       <span class="comment"></span>
<a name="l01182"></a>01182 <span class="comment">      /// constructor</span>
<a name="l01183"></a>01183 <span class="comment"></span>      <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a1a549eb5b415915d78f166b62490f07d" title="constructor">ArpackEigenSolver</a>(<span class="keyword">const</span> <a class="code" href="class_solver_1_1_eigen_solver_info.html">Solver::EigenSolverInfo</a>&amp; eigen_info,
<a name="l01184"></a>01184                         <span class="keyword">const</span> <a class="code" href="class_solver_1_1_linear_solver_info.html">Solver::LinearSolverInfo</a>&amp; linear_info);
<a name="l01185"></a>01185       
<a name="l01186"></a>01186       <span class="comment">// destructor</span>
<a name="l01187"></a>01187       <span class="keyword">virtual</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ace83a4456993f747d28f370de7847b4a">~ArpackEigenSolver</a>();
<a name="l01188"></a>01188       <span class="comment"></span>
<a name="l01189"></a>01189 <span class="comment">      /// this method clears the data structures of this object. This should be called </span>
<a name="l01190"></a>01190 <span class="comment">      /// each time the used finishes using this object.</span>
<a name="l01191"></a>01191 <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ae431bb68d0df1d58b94921aa6a192148">clear</a>();
<a name="l01192"></a>01192       
<a name="l01193"></a>01193       <span class="comment"></span>
<a name="l01194"></a>01194 <span class="comment">      /// @returns the number of converged eigen pairs</span>
<a name="l01195"></a>01195 <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#aa6d9b9ef804a7596f69b283433a8ac77">getNConvergedEigenPairs</a>();
<a name="l01196"></a>01196       
<a name="l01197"></a>01197       
<a name="l01198"></a>01198       <span class="comment"></span>
<a name="l01199"></a>01199 <span class="comment">      /// this method returns the eigen valie</span>
<a name="l01200"></a>01200 <span class="comment">      /// @param pair_index index of the requested eigenvalue</span>
<a name="l01201"></a>01201 <span class="comment">      /// @param real_value real part of the eigenvalue</span>
<a name="l01202"></a>01202 <span class="comment">      /// @param img_value imaginary part of the eigenvalue</span>
<a name="l01203"></a>01203 <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#afdd1d986d1ada8d3099a51a00da2c865">getEigenValue</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eigen_index,
<a name="l01204"></a>01204                                  <span class="keywordtype">double</span>* real_value,
<a name="l01205"></a>01205                                  <span class="keywordtype">double</span>* img_value);
<a name="l01206"></a>01206       
<a name="l01207"></a>01207       <span class="comment"></span>
<a name="l01208"></a>01208 <span class="comment">      /// this method returns the eigen pair </span>
<a name="l01209"></a>01209 <span class="comment">      /// @param pair_index index of the requested eigenpair</span>
<a name="l01210"></a>01210 <span class="comment">      /// @param real_value real part of the eigenvalue</span>
<a name="l01211"></a>01211 <span class="comment">      /// @param img_value imaginary part of the eigenvalue</span>
<a name="l01212"></a>01212 <span class="comment">      /// @param real_vec real part of the eigenvector</span>
<a name="l01213"></a>01213 <span class="comment">      /// @param img_vec imaginary part of the eigenvector</span>
<a name="l01214"></a>01214 <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a5a157cf6ca5fe22d11620fc1c338dbd6">getEigenPair</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pair_index,
<a name="l01215"></a>01215                                 <span class="keywordtype">double</span>* real_value,
<a name="l01216"></a>01216                                 <span class="keywordtype">double</span>* img_value, 
<a name="l01217"></a>01217                                 NumericVector&lt;double&gt;&amp; real_vec,
<a name="l01218"></a>01218                                 NumericVector&lt;double&gt;&amp; img_vec);
<a name="l01219"></a>01219       
<a name="l01220"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a83e116f4f02f7f7abcfcde7d3008dd88">01220</a>       <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a83e116f4f02f7f7abcfcde7d3008dd88">getInvariantSubspace</a>(std::vector&lt;NumericVector&lt;double&gt;*&gt;&amp; vectors) {abort();}
<a name="l01221"></a>01221 
<a name="l01222"></a>01222       <span class="comment"></span>
<a name="l01223"></a>01223 <span class="comment">      /// this method computes and returns the residual error for the specified </span>
<a name="l01224"></a>01224 <span class="comment">      /// eigen value index. This is only for Hermitian problems</span>
<a name="l01225"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ab24aa4c50b14f1de013255e9547b50e1">01225</a> <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ab24aa4c50b14f1de013255e9547b50e1">getEigenPairResidualError</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)
<a name="l01226"></a>01226       {
<a name="l01227"></a>01227         <span class="comment">// unused parameter</span>
<a name="l01228"></a>01228         (void) index;
<a name="l01229"></a>01229         
<a name="l01230"></a>01230         Assert(<span class="keyword">false</span>, ExcInternalError());
<a name="l01231"></a>01231         <span class="keywordflow">return</span> 0.0;
<a name="l01232"></a>01232       }
<a name="l01233"></a>01233       
<a name="l01234"></a>01234       <span class="comment"></span>
<a name="l01235"></a>01235 <span class="comment">      /// this method computes and returns the relative error for the specified eigen value </span>
<a name="l01236"></a>01236 <span class="comment">      /// index. This is only for Hermitian problems</span>
<a name="l01237"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a10c269807f00dcad0db81ea21cb757c6">01237</a> <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a10c269807f00dcad0db81ea21cb757c6">getEigenPairRelativeError</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index)
<a name="l01238"></a>01238       {
<a name="l01239"></a>01239         <span class="comment">// unused parameter</span>
<a name="l01240"></a>01240         (void) index;
<a name="l01241"></a>01241         
<a name="l01242"></a>01242         Assert(<span class="keyword">false</span>, ExcInternalError());
<a name="l01243"></a>01243         <span class="keywordflow">return</span> 0.0;
<a name="l01244"></a>01244       }
<a name="l01245"></a>01245       
<a name="l01246"></a>01246       <span class="comment"></span>
<a name="l01247"></a>01247 <span class="comment">      /// method to solve the eigen system</span>
<a name="l01248"></a>01248 <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a5447976a369a100d19520f61b716d286" title="method to solve the eigen system">solve</a>(SparseMatrix&lt;double&gt;* A_mat, SparseMatrix&lt;double&gt;* B_mat = NULL);
<a name="l01249"></a>01249       <span class="comment"></span>
<a name="l01250"></a>01250 <span class="comment">      /// this method calculates a residual for the given eigen value and returns it</span>
<a name="l01251"></a>01251 <span class="comment"></span>      <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a9e9170ea95373792bd3d8be2669fe9a9" title="this method calculates a residual for the given eigen value and returns it">getResidualForEigenPair</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i);
<a name="l01252"></a>01252       
<a name="l01253"></a>01253     <span class="keyword">protected</span>:
<a name="l01254"></a>01254       <span class="comment"></span>
<a name="l01255"></a>01255 <span class="comment">      /// this prepares the solver for a solution by clearing the necessary data structures   </span>
<a name="l01256"></a>01256 <span class="comment"></span>      <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#abdf6565afdfaf783ce91458479eed92f" title="this prepares the solver for a solution by clearing the necessary data structures">intermediateClear</a>();
<a name="l01257"></a>01257       <span class="comment"></span>
<a name="l01258"></a>01258 <span class="comment">      /// this prepares the data structures for solution, depending upon the number of degrees of freedom   </span>
<a name="l01259"></a>01259 <span class="comment"></span>      <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a3ebfb1ceb5e5869d6198d30a38b08e90" title="this prepares the data structures for solution, depending upon the number of degrees of freedom...">prepare</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimensions);
<a name="l01260"></a>01260       <span class="comment"></span>
<a name="l01261"></a>01261 <span class="comment">      /// this initializes the linear solver for solution</span>
<a name="l01262"></a>01262 <span class="comment"></span>      <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a784036c03450a93e78ccae30ae71af20" title="this initializes the linear solver for solution">initLinearSolver</a>(SparseMatrix&lt;double&gt;* A_mat,
<a name="l01263"></a>01263                             SparseMatrix&lt;double&gt;* B_mat);
<a name="l01264"></a>01264       <span class="comment"></span>
<a name="l01265"></a>01265 <span class="comment">      /// checks for the error number from the solver</span>
<a name="l01266"></a>01266 <span class="comment"></span>      <span class="keywordtype">void</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#aa55ad44a60d864d7e9482cf4d7b1375d" title="checks for the error number from the solver">checkError</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ierr);
<a name="l01267"></a>01267       <span class="comment"></span>
<a name="l01268"></a>01268 <span class="comment">      /// linear solver used by this eigen solver</span>
<a name="l01269"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a12bd483d5a6e166800483772e39cfae8">01269</a> <span class="comment"></span>      std::auto_ptr&lt;Solver::LinearSolver&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a12bd483d5a6e166800483772e39cfae8" title="linear solver used by this eigen solver">linear_solver</a>;
<a name="l01270"></a>01270       <span class="comment"></span>
<a name="l01271"></a>01271 <span class="comment">      /// if the solution has been performed</span>
<a name="l01272"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a5e46bb22e166d87a13702d5b3b006b14">01272</a> <span class="comment"></span>      <span class="keywordtype">bool</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a5e46bb22e166d87a13702d5b3b006b14" title="if the solution has been performed">solution_completed</a>;
<a name="l01273"></a>01273       <span class="comment"></span>
<a name="l01274"></a>01274 <span class="comment">      /// number of converged eigenpairs</span>
<a name="l01275"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a404174330e6edf3e95f16a077e4826de">01275</a> <span class="comment"></span>      <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a404174330e6edf3e95f16a077e4826de" title="number of converged eigenpairs">n_converged_eigen_pairs</a>;
<a name="l01276"></a>01276       
<a name="l01277"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a500bd70871f2ada438c4b7e6e02d5f5c">01277</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a500bd70871f2ada438c4b7e6e02d5f5c">ido</a>;
<a name="l01278"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a6b87534a1e3811a532d77e9019419e4c">01278</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a6b87534a1e3811a532d77e9019419e4c">n</a>;
<a name="l01279"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ae42733514301b3fd0be8490fd74f2748">01279</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ae42733514301b3fd0be8490fd74f2748">nev</a>;
<a name="l01280"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a450ed5eb88dc1f5e6c3f4fdd2f161bb9">01280</a>       <span class="keywordtype">double</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a450ed5eb88dc1f5e6c3f4fdd2f161bb9">tol</a>;
<a name="l01281"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#abb47bd58e4542cca7410bedf18f7beaa">01281</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#abb47bd58e4542cca7410bedf18f7beaa">ncv</a>;
<a name="l01282"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a66273634566134863e2ae1a01dd557be">01282</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a66273634566134863e2ae1a01dd557be">ldv</a>;
<a name="l01283"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a68451b2d8020913bef52b673564f571f">01283</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a68451b2d8020913bef52b673564f571f">lworkl</a>;
<a name="l01284"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ae81b08558cac1ca6940ad05fcf81a382">01284</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ae81b08558cac1ca6940ad05fcf81a382">info</a>;
<a name="l01285"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a5997f0b24fa2e0c604c8daeebe86020c">01285</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a5997f0b24fa2e0c604c8daeebe86020c">rvec</a>;
<a name="l01286"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#af4b12eb983aa063ae5e360e5b686fb8d">01286</a>       <span class="keywordtype">int</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#af4b12eb983aa063ae5e360e5b686fb8d">ldz</a>;
<a name="l01287"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a3293c0c13bc5fa53f637f39bf210ce61">01287</a>       <span class="keywordtype">double</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a3293c0c13bc5fa53f637f39bf210ce61">sigmar</a>;
<a name="l01288"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a4ca48a828601f610af8d1d3113862c9d">01288</a>       <span class="keywordtype">double</span> <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a4ca48a828601f610af8d1d3113862c9d">sigmai</a>;
<a name="l01289"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#adafab36e475f09513d603b5f6427ac98">01289</a>       std::string <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#adafab36e475f09513d603b5f6427ac98">bmat</a>;
<a name="l01290"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a7467a41d822ce790f546940c6c746860">01290</a>       std::string <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a7467a41d822ce790f546940c6c746860">which</a>;
<a name="l01291"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a71611799f12dcd921d707576c5b163f7">01291</a>       std::string <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a71611799f12dcd921d707576c5b163f7">HowMny</a>;
<a name="l01292"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a8d04909e0e4aac3aea9d0f58764bbd6e">01292</a>       std::vector&lt;int&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a8d04909e0e4aac3aea9d0f58764bbd6e">select</a>;
<a name="l01293"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a308ad8fae410dda5036d7d402ab2a7dc">01293</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a308ad8fae410dda5036d7d402ab2a7dc">Z</a>;
<a name="l01294"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a6c627658131a4e7fa8329621ce697dff">01294</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a6c627658131a4e7fa8329621ce697dff">dr</a>;
<a name="l01295"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a95f4da7fdb0ca57328eb0278d40d5cd2">01295</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a95f4da7fdb0ca57328eb0278d40d5cd2">di</a>;
<a name="l01296"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a603c8df17f149c6820834a0802cd1ef9">01296</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a603c8df17f149c6820834a0802cd1ef9">V</a>;
<a name="l01297"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#af53cee1e09bb167068ff999873fab07c">01297</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#af53cee1e09bb167068ff999873fab07c">resid</a>;
<a name="l01298"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a9b3edf6e0a69de3632dd2d3f9d7eab89">01298</a>       std::vector&lt;int&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a9b3edf6e0a69de3632dd2d3f9d7eab89">iparam</a>;
<a name="l01299"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ae73755f0bee2dfa1b9daf0cf0e6e4d9b">01299</a>       std::vector&lt;int&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#ae73755f0bee2dfa1b9daf0cf0e6e4d9b">ipntr</a>;
<a name="l01300"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#afdee80b97daa43cdbe81c935ac3e8047">01300</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#afdee80b97daa43cdbe81c935ac3e8047">workd</a>;
<a name="l01301"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a04a3845e27805c60771937a363fb6b05">01301</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a04a3845e27805c60771937a363fb6b05">workev</a>;
<a name="l01302"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a7044156f975271742adf7508f75436d2">01302</a>       std::vector&lt;double&gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a7044156f975271742adf7508f75436d2">workl</a>;
<a name="l01303"></a><a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a96430d2450b26226530349191a93f34a">01303</a>       std::auto_ptr&lt;SparseMatrix&lt;double&gt; &gt; <a class="code" href="class_solver_1_1_arpack_eigen_solver.html#a96430d2450b26226530349191a93f34a">operator_matrix</a>;
<a name="l01304"></a>01304     };
<a name="l01305"></a>01305   
<a name="l01306"></a>01306 }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 
<a name="l01309"></a>01309 <span class="preprocessor">#endif // __fesystem_arpack_eigen_solver_h__</span>
<a name="l01310"></a>01310 <span class="preprocessor"></span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 12 2012 18:06:18 for fesystem by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
