<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>fesystem: Solver::NewmarkSolver Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">fesystem
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_solver.html">Solver</a>      </li>
      <li class="navelem"><a class="el" href="namespace_solver_1_1_newmark_solver.html">NewmarkSolver</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Solver::NewmarkSolver Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_solver_1_1_newmark_solver.html#ad70ca609b3bff4982d3bd3a08ce20eec">getResidual</a> (NumericVector&lt; double &gt; &amp;sol, NumericVector&lt; double &gt; &amp;res, void *ctx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">function to be called by the nonlinear solver for the residual function  <a href="#ad70ca609b3bff4982d3bd3a08ce20eec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_solver_1_1_newmark_solver.html#a7f50365574762304692c3d36039e6c32">getJacobian</a> (NumericVector&lt; double &gt; &amp;sol, SparseMatrix&lt; double &gt; &amp;jac, void *ctx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">function to be called by the nonlinear solver for a jacobian matrix  <a href="#a7f50365574762304692c3d36039e6c32"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NewmarkInfoType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_solver_1_1_newmark_solver.html#a76547682223a90ee3fd624b04ff870c8">initNewmarkConstants</a> (const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constants_vector)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NewmarkInfoType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_solver_1_1_newmark_solver.html#afadb0dc2d230bdd6b218977920f450e4">initNewmarkStiffnessMatrix</a> (const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constants_vector, std::vector&lt; SparseMatrix&lt; double &gt; * &gt; &amp;coeff_matrices, SparseMatrix&lt; double &gt; &amp;newmark_stiff_matrix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">given all constants, this calculates the LHS matrix of the linear dynamic system  <a href="#afadb0dc2d230bdd6b218977920f450e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NewmarkInfoType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_solver_1_1_newmark_solver.html#aae63d6eafcaf74395ca4cd9f9027df82">initNewmarkForceVector</a> (const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constant_vector, std::vector&lt; SparseMatrix&lt; double &gt; * &gt; &amp;coeff_matrices, std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;state_vectors, NumericVector&lt; double &gt; &amp;external_force_vec, NumericVector&lt; double &gt; &amp;scratch_vec1, NumericVector&lt; double &gt; &amp;scratch_vec2, NumericVector&lt; double &gt; &amp;newmark_force_vec)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NewmarkInfoType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c">updateStateVectors</a> (const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constant_vector, std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;previous_state_vector, std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;new_state_vector)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7f50365574762304692c3d36039e6c32"></a><!-- doxytag: member="Solver::NewmarkSolver::getJacobian" ref="a7f50365574762304692c3d36039e6c32" args="(NumericVector&lt; double &gt; &amp;sol, SparseMatrix&lt; double &gt; &amp;jac, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_solver_1_1_newmark_solver.html#a7f50365574762304692c3d36039e6c32">Solver::NewmarkSolver::getJacobian</a> </td>
          <td>(</td>
          <td class="paramtype">NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>function to be called by the nonlinear solver for a jacobian matrix </p>

<p>Definition at line <a class="el" href="_newmark_transient_solver_8_c_source.html#l00544">544</a> of file <a class="el" href="_newmark_transient_solver_8_c_source.html">NewmarkTransientSolver.C</a>.</p>

<p>References <a class="el" href="_f_e_system_solver_base_8h_source.html#l00077">Solver::FESystemSolverBase::analysis_driver</a>, <a class="el" href="_transient_solver_8h_source.html#l00129">Solver::TransientSolverBase::coefficient_matrices</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00220">Solver::NewmarkNonlinearTransientSolver::current_state_vectors</a>, <a class="el" href="_newmark_transient_solver_8_c_source.html#l00673">Solver::NewmarkNonlinearTransientSolver::getCurrentTime()</a>, <a class="el" href="_autoptr_vector_8h_source.html#l00169">FESystemUtility::AutoPtrVector&lt; T &gt;::getReference()</a>, <a class="el" href="_newmark_transient_solver_info_8_c_source.html#l00112">Solver::NewmarkNonlinearTransientSolverInfo::getSystemOrder()</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00216">Solver::NewmarkNonlinearTransientSolver::last_iter_state_vectors</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00224">Solver::NewmarkNonlinearTransientSolver::new_state_vectors</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00212">Solver::NewmarkNonlinearTransientSolver::newmark_constants</a>, <a class="el" href="_transient_solver_8h_source.html#l00125">Solver::TransientSolverBase::transient_solver_info</a>, and <a class="el" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c">updateStateVectors()</a>.</p>

<p>Referenced by <a class="el" href="_newmark_transient_solver_8_c_source.html#l00347">Solver::NewmarkNonlinearTransientSolver::solve()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html">Solver::NewmarkNonlinearTransientSolver</a>* solver = 
  <span class="keyword">static_cast&lt;</span><a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html">Solver::NewmarkNonlinearTransientSolver</a>*<span class="keyword">&gt;</span> (ctx);
  
  <span class="keyword">const</span> <a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html" title="this is a class specifically for linear transient solvers">Solver::NewmarkNonlinearTransientSolverInfo</a>&amp; newmark_info =
  <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html" title="this is a class specifically for linear transient solvers">Solver::NewmarkNonlinearTransientSolverInfo</a>&amp;<span class="keyword">&gt;</span>(solver-&gt;<a class="code" href="class_solver_1_1_transient_solver_base.html#a611e556bed59cb54163e73099d18edfa" title="TransientSolverInfo that stores information about this solver.">transient_solver_info</a>);
  
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> system_order = newmark_info.<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html#ad5eb8a8dd3930e4c3a1b95361b856a8e">getSystemOrder</a>();
  
  <span class="comment">// copy the previous iteration solutions needef for calculation of new state vectors</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt;= system_order; i++)
    {
      *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>[i]) = *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a1982a78111d08eb34fe4ee02f5746e06">last_iter_state_vectors</a>[i]);
      solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>[i]-&gt;close();
    }
  
  <span class="comment">// now copy the new approximation and calculate the residual</span>
  sol.close();
  *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>[0]) = *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a1982a78111d08eb34fe4ee02f5746e06">last_iter_state_vectors</a>[0]);
  solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>[0]-&gt;add(1.0, sol);
  solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>[0]-&gt;close();
  
  <span class="comment">// calculate the new derivatives</span>
  <a class="code" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c">Solver::NewmarkSolver::updateStateVectors</a>
  (newmark_info,
   solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a3087a480e6b481d00958bba5bfa7a313">newmark_constants</a>,
   solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>.<a class="code" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object.">getReference</a>(),
   solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>.<a class="code" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object.">getReference</a>());
  
  <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_driver_1_1_nonlinear_transient_analysis_driver.html" title="this is the base for nonlinear transient analysis drivers of various orders">Driver::NonlinearTransientAnalysisDriver</a>*<span class="keyword">&gt;</span>(solver-&gt;<a class="code" href="class_solver_1_1_f_e_system_solver_base.html#ad52a2063f53a41980f6da440ba289c64" title="analysis driver pointer">analysis_driver</a>)-&gt;
  getJacobianMatrix(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a4ebb83ac8a95fe821edc927014640844">getCurrentTime</a>(),
                    solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>.<a class="code" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object.">getReference</a>(),
                    jac);
  
  jac.close();
  
  <span class="comment">// now, get the coefficient matrices to add to the jacobian</span>
  std::vector&lt;SparseMatrix&lt;double&gt;*&gt; coeff_mats(system_order + 1);
  
  <span class="keywordflow">switch</span> (system_order)
  {
    <span class="keywordflow">case</span> 1:
    {
      <span class="comment">// only the C1 matrix is needed</span>
      coeff_mats[0] = NULL;
      coeff_mats[1] = solver-&gt;<a class="code" href="class_solver_1_1_transient_solver_base.html#ad151a15f38707a3d3f2f8439b637be0f">coefficient_matrices</a>[1];
      
      <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_driver_1_1_nonlinear_transient_analysis_driver.html" title="this is the base for nonlinear transient analysis drivers of various orders">Driver::NonlinearTransientAnalysisDriver</a>*<span class="keyword">&gt;</span>(solver-&gt;<a class="code" href="class_solver_1_1_f_e_system_solver_base.html#ad52a2063f53a41980f6da440ba289c64" title="analysis driver pointer">analysis_driver</a>)-&gt;
      getCoefficientMatrices(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a4ebb83ac8a95fe821edc927014640844">getCurrentTime</a>(),
                             solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>.<a class="code" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object.">getReference</a>(),
                             coeff_mats);
      coeff_mats[1]-&gt;close();
      jac.add(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a3087a480e6b481d00958bba5bfa7a313">newmark_constants</a>[0], *(coeff_mats[1]));
      jac.close();
    }
      <span class="keywordflow">break</span>;
      
    <span class="keywordflow">default</span>:
      Assert(<span class="keyword">false</span>, ExcInternalError());
  }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_solver_1_1_newmark_solver_a7f50365574762304692c3d36039e6c32_cgraph.gif" border="0" usemap="#namespace_solver_1_1_newmark_solver_a7f50365574762304692c3d36039e6c32_cgraph" alt=""/></div>
<map name="namespace_solver_1_1_newmark_solver_a7f50365574762304692c3d36039e6c32_cgraph" id="namespace_solver_1_1_newmark_solver_a7f50365574762304692c3d36039e6c32_cgraph">
<area shape="rect" id="node3" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a4ebb83ac8a95fe821edc927014640844" title="Solver::NewmarkNonlinearTransientSolver::getCurrentTime" alt="" coords="307,5,680,33"/><area shape="rect" id="node5" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object." alt="" coords="347,57,640,85"/><area shape="rect" id="node7" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html#ad5eb8a8dd3930e4c3a1b95361b856a8e" title="Solver::NewmarkNonlinearTransientSolverInfo::getSystemOrder" alt="" coords="294,109,693,137"/><area shape="rect" id="node9" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c" title="Solver::NewmarkSolver::updateStateVectors" alt="" coords="351,161,636,189"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad70ca609b3bff4982d3bd3a08ce20eec"></a><!-- doxytag: member="Solver::NewmarkSolver::getResidual" ref="ad70ca609b3bff4982d3bd3a08ce20eec" args="(NumericVector&lt; double &gt; &amp;sol, NumericVector&lt; double &gt; &amp;res, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_solver_1_1_newmark_solver.html#ad70ca609b3bff4982d3bd3a08ce20eec">Solver::NewmarkSolver::getResidual</a> </td>
          <td>(</td>
          <td class="paramtype">NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>function to be called by the nonlinear solver for the residual function </p>

<p>Definition at line <a class="el" href="_newmark_transient_solver_8_c_source.html#l00502">502</a> of file <a class="el" href="_newmark_transient_solver_8_c_source.html">NewmarkTransientSolver.C</a>.</p>

<p>References <a class="el" href="_f_e_system_solver_base_8h_source.html#l00077">Solver::FESystemSolverBase::analysis_driver</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00220">Solver::NewmarkNonlinearTransientSolver::current_state_vectors</a>, <a class="el" href="_newmark_transient_solver_8_c_source.html#l00673">Solver::NewmarkNonlinearTransientSolver::getCurrentTime()</a>, <a class="el" href="_autoptr_vector_8h_source.html#l00169">FESystemUtility::AutoPtrVector&lt; T &gt;::getReference()</a>, <a class="el" href="_newmark_transient_solver_info_8_c_source.html#l00112">Solver::NewmarkNonlinearTransientSolverInfo::getSystemOrder()</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00216">Solver::NewmarkNonlinearTransientSolver::last_iter_state_vectors</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00224">Solver::NewmarkNonlinearTransientSolver::new_state_vectors</a>, <a class="el" href="_newmark_transient_solver_8h_source.html#l00212">Solver::NewmarkNonlinearTransientSolver::newmark_constants</a>, <a class="el" href="_transient_solver_8h_source.html#l00125">Solver::TransientSolverBase::transient_solver_info</a>, and <a class="el" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c">updateStateVectors()</a>.</p>

<p>Referenced by <a class="el" href="_newmark_transient_solver_8_c_source.html#l00347">Solver::NewmarkNonlinearTransientSolver::solve()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html">Solver::NewmarkNonlinearTransientSolver</a>* solver = 
  <span class="keyword">static_cast&lt;</span><a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html">Solver::NewmarkNonlinearTransientSolver</a>*<span class="keyword">&gt;</span> (ctx);
  
  <span class="keyword">const</span> <a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html" title="this is a class specifically for linear transient solvers">Solver::NewmarkNonlinearTransientSolverInfo</a>&amp; newmark_info =
  <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html" title="this is a class specifically for linear transient solvers">Solver::NewmarkNonlinearTransientSolverInfo</a>&amp;<span class="keyword">&gt;</span>(solver-&gt;<a class="code" href="class_solver_1_1_transient_solver_base.html#a611e556bed59cb54163e73099d18edfa" title="TransientSolverInfo that stores information about this solver.">transient_solver_info</a>);
  
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> system_order = newmark_info.<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html#ad5eb8a8dd3930e4c3a1b95361b856a8e">getSystemOrder</a>();
  
  <span class="comment">// copy the previous iteration solutions needef for calculation of new state vectors</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt;= system_order; i++)
    {
      *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>[i]) = *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a1982a78111d08eb34fe4ee02f5746e06">last_iter_state_vectors</a>[i]);
      solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>[i]-&gt;close();
    }
  
  <span class="comment">// now copy the new approximation and calculate the residual</span>
  sol.close();
  *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>[0]) = *(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a1982a78111d08eb34fe4ee02f5746e06">last_iter_state_vectors</a>[0]);
  solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>[0]-&gt;add(1.0, sol);
  solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>[0]-&gt;close();
  
  <span class="comment">// calculate the new derivatives</span>
  <a class="code" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c">Solver::NewmarkSolver::updateStateVectors</a>
  (newmark_info,
   solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a3087a480e6b481d00958bba5bfa7a313">newmark_constants</a>,
   solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>.<a class="code" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object.">getReference</a>(),
   solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#ac9a53ce3fe302e4c47d80983cca9ffc1">new_state_vectors</a>.<a class="code" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object.">getReference</a>());
  
  <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_driver_1_1_nonlinear_transient_analysis_driver.html" title="this is the base for nonlinear transient analysis drivers of various orders">Driver::NonlinearTransientAnalysisDriver</a>*<span class="keyword">&gt;</span>(solver-&gt;<a class="code" href="class_solver_1_1_f_e_system_solver_base.html#ad52a2063f53a41980f6da440ba289c64" title="analysis driver pointer">analysis_driver</a>)-&gt;
  getResidualVector(solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a4ebb83ac8a95fe821edc927014640844">getCurrentTime</a>(),
                    solver-&gt;<a class="code" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a207bd6f61688746478d33ad3d9394b25">current_state_vectors</a>.<a class="code" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object.">getReference</a>(),
                    res);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_solver_1_1_newmark_solver_ad70ca609b3bff4982d3bd3a08ce20eec_cgraph.gif" border="0" usemap="#namespace_solver_1_1_newmark_solver_ad70ca609b3bff4982d3bd3a08ce20eec_cgraph" alt=""/></div>
<map name="namespace_solver_1_1_newmark_solver_ad70ca609b3bff4982d3bd3a08ce20eec_cgraph" id="namespace_solver_1_1_newmark_solver_ad70ca609b3bff4982d3bd3a08ce20eec_cgraph">
<area shape="rect" id="node3" href="class_solver_1_1_newmark_nonlinear_transient_solver.html#a4ebb83ac8a95fe821edc927014640844" title="Solver::NewmarkNonlinearTransientSolver::getCurrentTime" alt="" coords="307,5,680,33"/><area shape="rect" id="node5" href="class_f_e_system_utility_1_1_auto_ptr_vector.html#a903c3fcc85d65dda940c6d2c5568394a" title="this returns a reference to the vector of this object." alt="" coords="347,57,640,85"/><area shape="rect" id="node7" href="class_solver_1_1_newmark_nonlinear_transient_solver_info.html#ad5eb8a8dd3930e4c3a1b95361b856a8e" title="Solver::NewmarkNonlinearTransientSolverInfo::getSystemOrder" alt="" coords="294,109,693,137"/><area shape="rect" id="node9" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c" title="Solver::NewmarkSolver::updateStateVectors" alt="" coords="351,161,636,189"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a76547682223a90ee3fd624b04ff870c8"></a><!-- doxytag: member="Solver::NewmarkSolver::initNewmarkConstants" ref="a76547682223a90ee3fd624b04ff870c8" args="(const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constants_vector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewmarkInfoType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_solver_1_1_newmark_solver.html#a76547682223a90ee3fd624b04ff870c8">Solver::NewmarkSolver::initNewmarkConstants</a> </td>
          <td>(</td>
          <td class="paramtype">const NewmarkInfoType &amp;&#160;</td>
          <td class="paramname"><em>solver_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this calculates the constants of the Newmark solver. The order of the solver and the input constants are obtained from the solver_info object. </p>

<p>Referenced by <a class="el" href="_newmark_transient_solver_8_c_source.html#l00054">Solver::NewmarkLinearTransientSolver::solve()</a>, and <a class="el" href="_newmark_transient_solver_8_c_source.html#l00347">Solver::NewmarkNonlinearTransientSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="aae63d6eafcaf74395ca4cd9f9027df82"></a><!-- doxytag: member="Solver::NewmarkSolver::initNewmarkForceVector" ref="aae63d6eafcaf74395ca4cd9f9027df82" args="(const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constant_vector, std::vector&lt; SparseMatrix&lt; double &gt; * &gt; &amp;coeff_matrices, std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;state_vectors, NumericVector&lt; double &gt; &amp;external_force_vec, NumericVector&lt; double &gt; &amp;scratch_vec1, NumericVector&lt; double &gt; &amp;scratch_vec2, NumericVector&lt; double &gt; &amp;newmark_force_vec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewmarkInfoType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_solver_1_1_newmark_solver.html#aae63d6eafcaf74395ca4cd9f9027df82">Solver::NewmarkSolver::initNewmarkForceVector</a> </td>
          <td>(</td>
          <td class="paramtype">const NewmarkInfoType &amp;&#160;</td>
          <td class="paramname"><em>solver_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseMatrix&lt; double &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_force_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newmark_force_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>given all other matrices and vectors, this calculated the RHS of the linear dynamic system </p>

<p>Referenced by <a class="el" href="_newmark_transient_solver_8_c_source.html#l00054">Solver::NewmarkLinearTransientSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="afadb0dc2d230bdd6b218977920f450e4"></a><!-- doxytag: member="Solver::NewmarkSolver::initNewmarkStiffnessMatrix" ref="afadb0dc2d230bdd6b218977920f450e4" args="(const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constants_vector, std::vector&lt; SparseMatrix&lt; double &gt; * &gt; &amp;coeff_matrices, SparseMatrix&lt; double &gt; &amp;newmark_stiff_matrix)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewmarkInfoType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_solver_1_1_newmark_solver.html#afadb0dc2d230bdd6b218977920f450e4">Solver::NewmarkSolver::initNewmarkStiffnessMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const NewmarkInfoType &amp;&#160;</td>
          <td class="paramname"><em>solver_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SparseMatrix&lt; double &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newmark_stiff_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>given all constants, this calculates the LHS matrix of the linear dynamic system </p>

<p>Referenced by <a class="el" href="_newmark_transient_solver_8_c_source.html#l00054">Solver::NewmarkLinearTransientSolver::solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a75b5711308577dc7f07b6746cdefdf6c"></a><!-- doxytag: member="Solver::NewmarkSolver::updateStateVectors" ref="a75b5711308577dc7f07b6746cdefdf6c" args="(const NewmarkInfoType &amp;solver_info, std::vector&lt; double &gt; &amp;constant_vector, std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;previous_state_vector, std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;new_state_vector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewmarkInfoType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_solver_1_1_newmark_solver.html#a75b5711308577dc7f07b6746cdefdf6c">Solver::NewmarkSolver::updateStateVectors</a> </td>
          <td>(</td>
          <td class="paramtype">const NewmarkInfoType &amp;&#160;</td>
          <td class="paramname"><em>solver_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous_state_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NumericVector&lt; double &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_state_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this initializes the state vector derivatives at the new iterate. This method is to be called after the new zeroth order vector has been calculated, so that all new derivtives can be calculated. The new zeroth order vector should be passed as the first element of the new_state_vector. When this function returns, the previous state vector will be updated with the new state vectors, and the new state vectors will all be zeroed </p>

<p>Referenced by <a class="el" href="_newmark_transient_solver_8_c_source.html#l00544">getJacobian()</a>, <a class="el" href="_newmark_transient_solver_8_c_source.html#l00502">getResidual()</a>, <a class="el" href="_newmark_transient_solver_8_c_source.html#l00054">Solver::NewmarkLinearTransientSolver::solve()</a>, and <a class="el" href="_newmark_transient_solver_8_c_source.html#l00347">Solver::NewmarkNonlinearTransientSolver::solve()</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 12 2012 18:06:23 for fesystem by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
